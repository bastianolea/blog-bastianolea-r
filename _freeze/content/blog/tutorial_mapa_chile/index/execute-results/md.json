{
  "hash": "5213be75b68b2ae552d10e6f8870e940",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Crea un mapa de Chile y visualiza datos comunales y regionales con mapas en R\nauthor: Bastián Olea Herrera\ndate: '2024-11-25'\ndraft: false\nfreeze: true\nformat: hugo-md\nslug: []\ncategories:\n  - tutoriales\ntags:\n  - mapas\n  - gráficos\n  - ciencias sociales\n  - Chile\neditor_options: \n  chunk_output_type: inline\nexecute: \n  warning: false\n  message: false\nexcerpt: Visualizar datos geográficamente es una herramienta de comunicación y análisis de datos muy potente. En este tutorial te explico cómo obtener mapas comunales y regionales de Chile en R, y cómo crear un gráficos que visualizan variables numéricas en las comunas y regiones del país. En pocos pasos puedes transformar tus datos territoriales en visualizaciones mucho más densas e informativas.\nlinks:\n  - icon: github\n    icon_pack: fab\n    name: código\n    url: https://gist.github.com/bastianolea/df03203e88534261ef831f2cb4fca254\n---\n\n{{< indice >}}\n\nVisualizar datos geográficamente es una herramienta de comunicación y análisis de datos muy potente. En este tutorial te explico cómo obtener mapas comunales y regionales de Chile en R, y cómo crear un gráficos que visualizan variables numéricas en las comunas y regiones del país. En pocos pasos puedes transformar tus datos territoriales en visualizaciones mucho más densas e informativas.\n\nPara crear mapas sencillos, donde una variable numérica se visualice en cada unidad territorial por medio de una escala de colores, solamente se necesitan dos cosas: la información geográfica que te permite visualizar el mapa en sí mismo, y los datos que podamos corresponder con las unidades territoriales del mapa.\n\nEn este breve tutorial veremos cómo obtener los mapas, como unir los datos al mapa, y cómo generar visualizaciones de estos mapas en R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(chilemapas) # mapas de chile\nlibrary(dplyr) # manipulación de datos\nlibrary(ggplot2) # visualización de datos\nlibrary(scales) # utilidad para visualización de datos\nlibrary(sf) # manipulación de datos geográficos\n```\n:::\n\n\n## Mapa de Chile por comunas\n\nEl paquete [`{chilemapas}`](https://pacha.dev/chilemapas/), desarrollado por [Mauricio Vargas](https://pacha.dev), ofrece una colección de mapas terrestres de Chile con topología simplificada. Simplemente llamando el objeto `mapa_comunas` obtenemos un dataframe con la información geográfica de cada comuna del país.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_comunas <- chilemapas::mapa_comunas\n\nmapa_comunas\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 345 × 4\n   codigo_comuna codigo_provincia codigo_region                         geometry\n   <chr>         <chr>            <chr>                       <MULTIPOLYGON [°]>\n 1 01401         014              01            (((-68.86081 -21.28512, -68.921…\n 2 01403         014              01            (((-68.65113 -19.77188, -68.811…\n 3 01405         014              01            (((-68.65113 -19.77188, -68.635…\n 4 01402         014              01            (((-69.31789 -19.13651, -69.271…\n 5 01404         014              01            (((-69.39615 -19.06125, -69.400…\n 6 01107         011              01            (((-70.1095 -20.35131, -70.1243…\n 7 01101         011              01            (((-70.09894 -20.08504, -70.102…\n 8 02104         021              02            (((-68.98863 -25.38016, -68.987…\n 9 02101         021              02            (((-70.60654 -23.43054, -70.601…\n10 02201         022              02            (((-67.94302 -22.38175, -67.955…\n# ℹ 335 more rows\n```\n\n\n:::\n:::\n\n\nEn este dataframe, la columna `geometry` representa los polígonos de cada comuna. Esta información ya es suficiente para visualizar el mapa con R usando `{ggplot2}` y [`{sf}`, un paquete para trabajar con datos espaciales](https://r-spatial.github.io/sf/).\n\nPara visualizar el mapa, primero usamos `sf::st_set_geometry()` para asignar la geometría al dataframe. De este modo, le indicamos a R que estos datos deben graficarse en un mapa con determinadas coordenadas e información sobre proyección.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico_comunas <- mapa_comunas |> \n  st_set_geometry(mapa_comunas$geometry) |> # asignar geometría\n  ggplot() + # gráfico\n  geom_sf() # capa geométrica\n\ngrafico_comunas +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-3-1.png){width=768}\n:::\n:::\n\n\nDado que Chile tiene islas muy alejadas del territorio continental, como Rapa Nui o Juan Fernández, el mapa queda con mucho espacio en blanco. Podemos recortar las coordenadas de la longitud del mapa (el eje _x_ del gráfico) para que el mapa solamente abarque Chile continental: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico_comunas + \n  coord_sf(xlim = c(-77, -65)) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-4-1.png){width=288}\n:::\n:::\n\n\n## Mapa regional de Chile\n\nPara generar un mapa de regiones, debemos crear las regiones. Esto no es complicado si pensamos que, en el fondo, las regiones son simplemente la unión de las comunas que las componen. El paquete `{sf}` simplifica muchísimo el trabajo con datos geográficos, en este caso la unión de distintos polígonos en uno solo.\n\nAgrupamos las filas del dataframe por la variable `codigo_region`, para que todas las comunas que pertenecen a la misma región estén agrupadas, y usamos `summarize()` junto a la función `sf::st_union()` para que los polígonos de las comunas dentro de cada región se combinen, obteniendo polígonos regionales:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_regiones <- mapa_comunas |> \n  group_by(codigo_region) |> \n  summarize(geometry = st_union(geometry)) # resumir los datos agrupados uniéndolos\n\nmapa_regiones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   codigo_region                                                        geometry\n   <chr>                                                          <GEOMETRY [°]>\n 1 01            POLYGON ((-69.93023 -21.4246, -69.92376 -21.42622, -69.91932 -…\n 2 02            MULTIPOLYGON (((-68.0676 -24.32856, -67.91698 -24.26902, -67.8…\n 3 03            MULTIPOLYGON (((-71.58497 -29.02456, -71.58844 -29.02838, -71.…\n 4 04            MULTIPOLYGON (((-70.54551 -31.30742, -70.53877 -31.30074, -70.…\n 5 05            MULTIPOLYGON (((-71.33832 -33.45237, -71.33763 -33.44836, -71.…\n 6 06            POLYGON ((-71.5477 -34.87458, -71.54211 -34.87581, -71.53566 -…\n 7 07            POLYGON ((-70.41724 -35.63022, -70.41108 -35.6302, -70.40146 -…\n 8 08            MULTIPOLYGON (((-73.53466 -36.97378, -73.53245 -36.97829, -73.…\n 9 09            MULTIPOLYGON (((-73.35306 -38.73343, -73.35396 -38.72799, -73.…\n10 10            MULTIPOLYGON (((-73.1691 -41.87755, -73.16135 -41.87781, -73.1…\n11 11            MULTIPOLYGON (((-75.41754 -48.73857, -75.43249 -48.74372, -75.…\n12 12            MULTIPOLYGON (((-70.35563 -52.94478, -70.34688 -52.93971, -70.…\n13 13            POLYGON ((-70.47405 -33.8624, -70.47327 -33.86269, -70.46068 -…\n14 14            MULTIPOLYGON (((-73.39503 -39.88698, -73.39672 -39.89339, -73.…\n15 15            POLYGON ((-69.07223 -19.02723, -69.06394 -19.02607, -69.04748 …\n16 16            POLYGON ((-72.38553 -36.91169, -72.37685 -36.91617, -72.37034 …\n```\n\n\n:::\n:::\n\n\nObtenemos un dataframe con una fila por región, dado que las comunas fueron unidas en polígonos regionales. La columna `geometry` ahora contiene la unión de las comunas que hicimos con la función `st_union()`. Podemos visualizar este nuevo dataframe regional usando `{ggplot2}` y `{sf}`, igual que en el paso anterior:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrafico_regiones <- mapa_regiones |> \n  st_set_geometry(mapa_regiones$geometry) |> # especificar la geometría del mapa\n  ggplot() + # graficar\n  geom_sf() + # capa geográfica\n  coord_sf(xlim = c(-77, -65)) # recortar coordenadas\n\ngrafico_regiones +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-6-1.png){width=288}\n:::\n:::\n\n\nAhora que tenemos nuestros mapas por comunas y por regiones, la idea es poder utilizarlos para visualizar datos en ellos.\n\n## Visualizar datos en el mapa\n\nPara visualizar los datos en un mapa, aplicaremos colores a los distintos polígonos de nuestro mapa, ya sean comunas o regiones. La intensidad del color, o su posición dentro de la escala de color elegida, representará el valor de la variable numérica que queremos visualizar.\n\nLa idea de fondo para entender la visualización de datos geográficos por polígonos es entender que los mapas que obtuvimos contienen en cada fila un polígono (la información geográfica para dibujar la comuna o región), y además, en cada fila contienen información que identifica al polígono correspondiente. En nuestro caso, la información de los polígonos corresponde al _código único territorial_ de las comunas, y el código de regiones en el caso de las regiones. Éstos son códigos numéricos que identifican cada unidad territorial del país.\n\nLa idea es poder agregarle datos a nuestro mapa, de manera que las filas que representan unidades territoriales tengan también columnas con datos sobre dichas unidades territoriales.\n\nEntonces, deberíamos tener nuestro dataframe con el mapa, y otro dataframe donde tengamos los datos que queremos adjuntar al mapa. Si tenemos un mapa de comunas, tenemos que tener los datos por comuna que queremos agregarle al mapa. \n\n### Datos comunales\n\n#### Obtener datos por web scraping\nPara visualizar un mapa de datos comunales, primero obtendremos datos comunales desde Wikipedia. Usamos el paquete para hacer un web scraping y obtener una [tabla de datos de las comunas del país.](https://es.wikipedia.org/wiki/Anexo:Comunas_de_Chile)\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rvest)\n\n# dirección de wikipedia con tabla de comunas de Chile\nurl <- \"https://es.wikipedia.org/wiki/Anexo:Comunas_de_Chile\"\n\n# obtener tabla con datos de comunas con web scraping\ntabla <- session(url) |> \n  read_html() |> \n  html_table(convert = FALSE)\n\ntabla[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 346 × 12\n   CUT (Código Único Territori…¹ Nombre ``    Provincia Región `Superficie(km²)`\n   <chr>                         <chr>  <chr> <chr>     <chr>  <chr>            \n 1 15101                         Arica  \"\"    Arica     Arica… 4.799,4          \n 2 15102                         Camar… \"\"    Arica     Arica… 3.927            \n 3 15201                         Putre  \"\"    Parinaco… Arica… 5.902,5          \n 4 15202                         Gener… \"\"    Parinaco… Arica… 2.244,4          \n 5 01101                         Iquiq… \"\"    Iquique   Tarap… 2.242,1          \n 6 01107                         Alto … \"\"    Iquique   Tarap… 572.9            \n 7 01401                         Pozo … \"\"    Tamarugal Tarap… 13.765,8         \n 8 01402                         Camiña \"\"    Tamarugal Tarap… 2.200,2          \n 9 01403                         Colch… \"\"    Tamarugal Tarap… 4.015,6          \n10 01404                         Huara  \"\"    Tamarugal Tarap… 10.474,6         \n# ℹ 336 more rows\n# ℹ abbreviated name: ¹​`CUT (Código Único Territorial)`\n# ℹ 6 more variables: Población2020 <chr>, `Densidad(hab./km²)` <chr>,\n#   `IDH 2005` <chr>, `IDH 2005` <chr>, Latitud <chr>, Longitud <chr>\n```\n\n\n:::\n:::\n\nLuego obtener los datos, realizamos una pequeña limpieza. Limpiamos los nombres de las variables, seleccionamos las variables que nos interesan, y luego las convertimos apropiadamente a valores numéricos, donde tenemos que eliminar los separadores de miles, y transformar los separadores de decimales a puntos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\nlibrary(stringr)\n\n# limpiar datos\ndatos_comunas <- tabla[[1]] |> \n  clean_names() |> \n  # seleccionar y renombrar columnas\n  select(codigo_comuna = cut_codigo_unico_territorial,\n         nombre, region, superficie_km2,\n         poblacion = poblacion2020) |> \n  # eliminar espacios de la columna de población\n  mutate(poblacion = str_remove_all(poblacion, \" \"),\n         poblacion = as.numeric(poblacion)) |> \n  # eliminar los separadores de miles\n  mutate(superficie_km2 = str_remove_all(superficie_km2, \"\\\\.\"),\n         # convertir comas a puntos\n         superficie_km2 = str_replace(superficie_km2, \",\", \".\"),\n         superficie_km2 = as.numeric(superficie_km2))\n\ndatos_comunas\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 346 × 5\n   codigo_comuna nombre        region             superficie_km2 poblacion\n   <chr>         <chr>         <chr>                       <dbl>     <dbl>\n 1 15101         Arica         Arica y Parinacota          4799.    247552\n 2 15102         Camarones     Arica y Parinacota          3927       1233\n 3 15201         Putre         Arica y Parinacota          5902.      2515\n 4 15202         General Lagos Arica y Parinacota          2244.       810\n 5 01101         Iquique       Tarapacá                    2242.    223463\n 6 01107         Alto Hospicio Tarapacá                    5729     129999\n 7 01401         Pozo Almonte  Tarapacá                   13766.     17395\n 8 01402         Camiña        Tarapacá                    2200.      1375\n 9 01403         Colchane      Tarapacá                    4016.      1583\n10 01404         Huara         Tarapacá                   10475.      3000\n# ℹ 336 more rows\n```\n\n\n:::\n:::\n\n\nAhora que tenemos una tabla de datos que contiene la columna `codigo_comuna` con el código único territorial de las comunas, podemos unirla al mapa de comunas.\n\n\n\n#### Agregar datos a los mapas\nEsta operación de unir dos tablas de datos diferentes, pero que coinciden en una columna en común, se realiza [con la función `left_join()`](/blog/left_join/). El principio de `left_join()` es que tenemos dos tablas de datos, y ambas tablas de datos tienen una misma columna, que poseen los mismos valores (en nuestro caso, una columna con las comunas o los códigos únicos territoriales de las comunas). Entonces, ambas tablas se van a unir según la correspondencias de estas columnas en común.\n\n_Ejemplo:_\n\n::: {.cell}\n\n```{.r .cell-code}\ntabla_a <- tribble(~animal,   ~favorito, \n                   \"gato\",    \"pescado\", \n                   \"mapache\", \"basura\",\n                   \"perro\",   \"carne\")\n\ntabla_b <- tribble(~animal,   ~belleza, ~inteligencia, ~carisma,\n                   \"gato\",    8,        6,             5,\n                   \"perro\",   5,        2,             8,\n                   \"mapache\", 10,       7,             2)\n\nleft_join(tabla_a, \n          tabla_b, \n          by = \"animal\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  animal  favorito belleza inteligencia carisma\n  <chr>   <chr>      <dbl>        <dbl>   <dbl>\n1 gato    pescado        8            6       5\n2 mapache basura        10            7       2\n3 perro   carne          5            2       8\n```\n\n\n:::\n:::\n\nEn el ejemplo, tenemos dos tablas, donde las dos tienen una misma columna con los mismos datos, y otras columnas con datos distintos. Usando `left_join()` podemos unir ambas tablas de datos a partir de la columna que tienen en común. Como resultado obtenemos una nueva tabla que tiene todas las columnas.\n\n----\n\nProcedemos a unir los datos con el mapa usando `left_join()`, especificando en el argumento `by` que la unión sea a partir de la columna `codigo_comuna`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_comunas_2 <- mapa_comunas |> \n  # adjuntar datos al mapa, coincidiendo por columna de código de comunas\n  left_join(datos_comunas,\n            by = join_by(codigo_comuna)) |> \n  relocate(geometry, .after = 0) # tirar geometría al final\n\nmapa_comunas_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 345 × 8\n   codigo_comuna codigo_provincia codigo_region nombre     region superficie_km2\n   <chr>         <chr>            <chr>         <chr>      <chr>           <dbl>\n 1 01401         014              01            Pozo Almo… Tarap…         13766.\n 2 01403         014              01            Colchane   Tarap…          4016.\n 3 01405         014              01            Pica       Tarap…          8934.\n 4 01402         014              01            Camiña     Tarap…          2200.\n 5 01404         014              01            Huara      Tarap…         10475.\n 6 01107         011              01            Alto Hosp… Tarap…          5729 \n 7 01101         011              01            Iquique    Tarap…          2242.\n 8 02104         021              02            Taltal     Antof…         20405.\n 9 02101         021              02            Antofagas… Antof…         30718.\n10 02201         022              02            Calama     Antof…         15597.\n# ℹ 335 more rows\n# ℹ 2 more variables: poblacion <dbl>, geometry <MULTIPOLYGON [°]>\n```\n\n\n:::\n:::\n\n\nComo resultado, tenemos un nuevo dataframe que además de tener los datos geográficos de las comunas, también tiene nuevas columnas con datos que podemos visualizar.\n\n#### Visualizar datos comunales\n\nPara visualizar datos comunales en un mapa, especificamos la columna de geometría que contiene la información geográfica, y creamos un gráfico de `{ggplot2}`. En este gráfico, especificamos que el relleno de los polígonos (`fill`) se haga a partir de una de las variables numéricas. \n\nUsamos la función `geom_sf()` para agregar una capa de geometría a nuestro gráfico que contenga los polígonos territoriales de las comunas. Luego, definimos un tema, una paleta de colores, y corregimos la escala del eje horizontal. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_comunas_2 |> \n  st_set_geometry(mapa_comunas_2$geometry) |> # asignar geometría\n  ggplot() + # gráfico\n  aes(fill = poblacion) +\n  geom_sf(linewidth = 0) + # capa geométrica\n  theme_classic() +\n  scale_fill_distiller(type = \"seq\", palette = 12, \n                       labels = label_comma(big.mark = \".\")) + # colores\n  scale_x_continuous(breaks = seq(-76, -65, length.out = 3) |> floor()) + # escala x\n  coord_sf(xlim = c(-77, -65)) + # recortar coordenadas\n  theme(legend.key.width = unit(3, \"mm\"))\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-11-1.png){width=288}\n:::\n:::\n\nComo resultado obtenemos un mapa coroplético, o mapa de coropletas, que es un mapa donde cada región o polígono está relleno de un color que representa un valor en una escala de una variable.\n\nAcá hacemos otro mapa, usando el mismo código y simplemente cambiando la variable de relleno de los polígonos territoriales:\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_comunas_2 |> \n  st_set_geometry(mapa_comunas_2$geometry) |>\n  ggplot() +\n  aes(fill = superficie_km2) + # variable de relleno\n  geom_sf(linewidth = 0) +\n  theme_classic() +\n  scale_fill_distiller(type = \"seq\", palette = 11,\n                       labels = label_comma(big.mark = \".\")) + \n  scale_x_continuous(breaks = seq(-76, -65, length.out = 3) |> floor()) +\n  coord_sf(xlim = c(-77, -65)) + \n  theme(legend.key.width = unit(3, \"mm\"))\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-12-1.png){width=288}\n:::\n:::\n\n\n#### Mapa de una sola región, por comunas\n\nSi queremos visualizar una sola región del país, subdividida por comunas, tan sencillo como agregar un filtro a los datos que filtre las filas que pertenecen a la región que nos interesa. En este caso, vamos a visualizar la población por comunas de la región del Libertador General Bernardo O'Higgins:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# filtrar datos\nmapa_comunas_filtro <- mapa_comunas_2 |> \n  filter(codigo_region == \"06\")\n\n# mapa\nmapa_comunas_filtro |> \n  st_set_geometry(mapa_comunas_filtro$geometry) |>\n  ggplot() +\n  aes(fill = poblacion) +\n  geom_sf(linewidth = 0.12, color = \"white\") +\n  geom_sf_text(aes(label = comma(poblacion, big.mark = \".\")), \n               size = 2, color = \"white\", check_overlap = T) +\n  theme_classic() +\n  scale_fill_distiller(type = \"seq\", palette = 12,\n                       labels = label_comma(big.mark = \".\")) + \n  theme(legend.key.width = unit(3, \"mm\")) +\n  theme(axis.title = element_blank())\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-13-1.png){width=576}\n:::\n:::\n\n\nEn este caso, agregamos también la función `geom_sf_text()` para agregar una capa nuestro gráfico que contiene las cifras para cada comuna. Hay que tener en consideración que poner números o textos sobre mapas suele ser complejo, porque el mapa ya es denso visualmente, y agregarle texto puede hacer que se vuelva ilegible. Hay que tener especial cuidado en resolver situaciones como textos que pasan por encima de bordes en el mapa, que se ubican incorrectamente dentro de los polígonos, o que se sobreponen uno sobre otros debido a que los polígonos se ven muy pequeños dentro del mapa.\n\n----\n\n### Datos regionales\n\n#### Obtener datos por web scraping\n\nPara hacer el ejemplo de visualizar datos a nivel regional, nuevamente obtendremos datos a esta escala usando web scraping. Obtendremos una tabla del Producto Interno Bruto regional desde el [sitio web de el Banco Central de Chile.](https://si3.bcentral.cl/Siete/ES/Siete/Cuadro/CAP_CCNN/MN_CCNN76/CCNN2018_PIB_REGIONAL_N/637899740344107786)\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rvest)\n\n# dirección del sitio del banco central\nurl <- \"https://si3.bcentral.cl/Siete/ES/Siete/Cuadro/CAP_CCNN/MN_CCNN76/CCNN2018_PIB_REGIONAL_N/637899740344107786\"\n\n# obtener tabla con datos de comunas con web scraping\ntabla_pib <- session(url) |> \n  read_html() |> \n  html_table(convert = FALSE)\n```\n:::\n\nLimpiamos los datos seleccionando las columnas que necesitamos, transformando la columna a tipo numérico, y filtrando las filas para quedar solamente con las que corresponden a las regiones de Chile:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_regiones <- tabla_pib [[1]] |> \n  janitor::clean_names() |> \n  select(region = serie, pib = x2023) |> \n  mutate(pib = str_remove_all(pib, \"\\\\.\"),\n         pib = as.numeric(pib)) |> \n  filter(str_detect(region, \"Región\"))\n\ndatos_regiones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   region                                                 pib\n   <chr>                                                <dbl>\n 1 Región de Arica y Parinacota                          2169\n 2 Región de Tarapacá                                    7892\n 3 Región de Antofagasta                                31290\n 4 Región de Atacama                                     6004\n 5 Región de Coquimbo                                    9174\n 6 Región de Valparaíso                                 20275\n 7 Región Metropolitana de Santiago                    109143\n 8 Región del Libertador General Bernardo OHiggins      11910\n 9 Región del Maule                                     10348\n10 Región de Ñuble                                       4106\n11 Región del Biobío                                    16731\n12 Región de La Araucanía                                7743\n13 Región de Los Ríos                                    3561\n14 Región de Los Lagos                                   9432\n15 Región de Aysén del General Carlos Ibáñez del Campo   1573\n16 Región de Magallanes y de la Antártica Chilena        2490\n```\n\n\n:::\n:::\n\n\n#### Crear columna de códigos regionales\n\nLos datos que obtuvimos no contienen una variable con el código único territorial de las regiones, dado que es un dato que está en desuso desde la promulgación de una ley en 2018 que prohíbe el uso de los números en comunicaciones públicas. Sin embargo, en muchas base de datos oficiales se sigue usando la numeración de las regiones, principalmente para evitar problemas de diferencias en los nombres de las regiones, por ejemplo, si contienen o no las palabras _Región de_ o _Región del_ para cada región, si contienen tildes o no, si contienen abreviaciones o no, si contienen símbolos como _eñes_ o apóstrofes, etc. Todos estos problemas son resueltos por el uso de identificador numérico de las regiones.\n\nComo el mapa que obtuvimos con el paquete `{chilemapas}` utiliza el código regional, en el dato frente de nuestros datos crearemos una columna con los mismos códigos regionales, asignados a cada región a partir de la coincidencia con los textos. Por ejemplo, si el texto del nombre de la región contiene la palabra _Arica_, se le asigna el código `15`. Esta forma de asignar los códigos regionales puede ser inexacta, pero es muy sencillo confirmar si es que la asignación de códigos funciona correctamente, y también siempre es posible utilizar [expresiones regulares en `{stringr}`](https://stringr.tidyverse.org/articles/regular-expressions.html) para hacer coincidencias más flexibles, como por ejemplo, coincidir una palabra con un código sin importar si la palabra tiene o no tilde, o está mal escrita.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_regiones_2 <- datos_regiones |> \n  mutate(codigo_region = case_when(\n    str_detect(region, \"Arica\") ~ 15,\n    str_detect(region, \"Tarapacá\") ~ 1,\n    str_detect(region, \"Antofagasta\") ~ 2,\n    str_detect(region, \"Atacama\") ~ 3,\n    str_detect(region, \"Coquimbo\") ~ 4,\n    str_detect(region, \"Valparaíso\") ~ 5,\n    str_detect(region, \"Metropolitana\") ~ 13,\n    str_detect(region, \"Libertador General\") ~ 6,\n    str_detect(region, \"Maule\") ~ 7,\n    str_detect(region, \"Ñuble\") ~ 16,\n    str_detect(region, \"Biobío\") ~ 8,\n    str_detect(region, \"Araucanía\") ~ 9,\n    str_detect(region, \"Los Ríos\") ~ 14,\n    str_detect(region, \"Los Lagos\") ~ 10,\n    str_detect(region, \"Aysén\") ~ 11,\n    str_detect(region, \"Magallanes\") ~ 12\n  )) |> \n  rename(nombre_region = region)\n```\n:::\n\n\n#### Unir datos con mapa\n\nLuego de crear la variable de códigos regionales, podemos hacer la unión entre ambas tablas de datos, mapas y datos regionales, usando `left_join()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_regiones_2 <- mapa_regiones |> \n  mutate(codigo_region = as.numeric(codigo_region)) |> \n  left_join(datos_regiones_2,\n            by = join_by(codigo_region)) |> \n  relocate(geometry, .after = 0) # tirar columna al final\n\nmapa_regiones_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 4\n   codigo_region nombre_region                     pib                  geometry\n           <dbl> <chr>                           <dbl>            <GEOMETRY [°]>\n 1             1 Región de Tarapacá               7892 POLYGON ((-69.93023 -21.…\n 2             2 Región de Antofagasta           31290 MULTIPOLYGON (((-68.0676…\n 3             3 Región de Atacama                6004 MULTIPOLYGON (((-71.5849…\n 4             4 Región de Coquimbo               9174 MULTIPOLYGON (((-70.5455…\n 5             5 Región de Valparaíso            20275 MULTIPOLYGON (((-71.3383…\n 6             6 Región del Libertador General…  11910 POLYGON ((-71.5477 -34.8…\n 7             7 Región del Maule                10348 POLYGON ((-70.41724 -35.…\n 8             8 Región del Biobío               16731 MULTIPOLYGON (((-73.5346…\n 9             9 Región de La Araucanía           7743 MULTIPOLYGON (((-73.3530…\n10            10 Región de Los Lagos              9432 MULTIPOLYGON (((-73.1691…\n11            11 Región de Aysén del General C…   1573 MULTIPOLYGON (((-75.4175…\n12            12 Región de Magallanes y de la …   2490 MULTIPOLYGON (((-70.3556…\n13            13 Región Metropolitana de Santi… 109143 POLYGON ((-70.47405 -33.…\n14            14 Región de Los Ríos               3561 MULTIPOLYGON (((-73.3950…\n15            15 Región de Arica y Parinacota     2169 POLYGON ((-69.07223 -19.…\n16            16 Región de Ñuble                  4106 POLYGON ((-72.38553 -36.…\n```\n\n\n:::\n:::\n\n\n#### Visualizar datos regionales\nFinalmente, visualizamos los datos en un mapa regional de la misma forma que lo hicimos con los mapas comunales. Esta vez, el mapa y los datos vienen en una fila por región, con la variable `geometry` que conteniendo la geometría del polígono regional. Por tanto, el código es exactamente el mismo, y solamente cambia el dataframe que usamos para generar el gráfico:\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_regiones_2 |> \n  st_set_geometry(mapa_regiones_2$geometry) |> # asignar geometría\n  ggplot() + # gráfico\n  aes(fill = pib) +\n  geom_sf(linewidth = 0.12, color = \"white\") + # capa geométrica\n  theme_classic() +\n  scale_fill_distiller(type = \"seq\", palette = 18,\n                       labels = label_comma(big.mark = \".\")) +\n  scale_x_continuous(breaks = seq(-76, -65, length.out = 3) |> floor()) +\n  coord_sf(expand = F, xlim = c(-77, -65)) + # recortar coordenadas\n  theme(legend.key.width = unit(3, \"mm\"))\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-18-1.png){width=288}\n:::\n:::\n\n\n----\n\nVisualizar datos geográficamente es una herramienta de comunicación y análisis de datos muy potente. Personalmente, encuentro que el potencial de la visualización de datos en mapas radica mucho más allá de simplemente mapear una variable a un territorio, sino a **incentivar que el público analice el mapa en relación a todo el conjunto de conocimientos que tenemos sobre del espacio que habitamos, sus características sociales, y las desigualdades distribuidas en el territorio.** \n\n----\n\nSi este tutorial te sirvió, por favor considera hacerme una pequeña donación para poder tomarme un cafecito mientras escribo el siguiente tutorial 🥺\n\n{{< cafecito >}}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}