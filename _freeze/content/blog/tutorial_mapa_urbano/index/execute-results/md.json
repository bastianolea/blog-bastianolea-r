{
  "hash": "dda63b4ed5aa3c99db993c8aa2d1e127",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tutorial: Mapa de la zona urbana de la Región Metropolitana de Santiago en R\"\nauthor: \"Bastián Olea Herrera\"\ndate: 2024-06-12\ncategories: ['Tutoriales']\ntags: ['mapas', 'Chile']\nformat: hugo-md\nfreeze: true\nlang: es\neditor_options: \n  chunk_output_type: inline\nlinks:\n- icon: github\n  icon_pack: fab\n  name: código\n  url: https://github.com/bastianolea/tutorial_r_mapa_urbano_rm\n- icon: registered\n  icon_pack: fas\n  name: chilemapas\n  url: https://github.com/pachadotdev/chilemapas\n---\n\n\n\nEste tutorial de R te explicará paso a paso a cómo obtener mapas de todo Chile usando el paquete [`{chilemapas}` desarrollado por Mauricio Vargas](https://github.com/pachadotdev/chilemapas), y hacer gráficos con estos mapas usando `{ggplot2}`.\n\nEn la primera parte veremos cómo **obtener los mapas** y cómo **visualizar datos comunales** usando mapas en R. Si necesitas una guía sobre mapas en R, [revisa este post.](/blog/mapas_sf/)\n\nLuego, nos enfrentaremos a un problema común que se tiene al graficar un mapa de la Región Metropolitana de Santiago, que tiene que ver con la diferencia entre los límites comunales reales de cada comuna y los **límites urbanos** de las comunas. Es la diferencia entre tener un mapa de la RM que abarque sectores rurales como Paine y que llegue hasta Argentina, o un mapa que demarque la zona urbana de Santiago, aproximadamente correspondiente a la zona que atravieza el anillo de la autopista Américo Vespucio.\n\nCon un mapa de la superficie urbana de la Región Metropolitana, obtenemos una figura que es más familiar al habitante promedio de la región, y que es la que usalmente vemos en la cotidianeidad, en contraste con un mapa geográficamente correcto de todo el territorio regional.\n\n\n\n{{< indice >}}\n\n\n\n\n\n## Introducción\n\n### Paquetes\n\nPrimero cargamos los paquetes que usaremos en este tutorial. Si no tienes alguno de ellos, intálalo con `install.packages()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# datos\nlibrary(dplyr) #manipulación de datos\nlibrary(janitor) #limpieza de datos\nlibrary(stringr) #manipulación de texto\n\n# mapas\nlibrary(chilemapas) #mapas de chile\nlibrary(sf) #manipulación de mapas\n\n# gráficos\nlibrary(ggplot2) #visualización de datos\nlibrary(viridis) #escalas de colores\nlibrary(scales) #escalas numéricas\n\n# web scraping\nlibrary(rvest) #obtener datos desde páginas de internet\n```\n:::\n\n\n\n### Obtener un mapa regional\n\nPrimero, usaremos `{chilemapas}` para obtener los datos geográficos (polígonos o shapes) necesarios para producir un mapa de la Región Metropolitana:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# obtener mapa comunal\nmapa_comunas <- chilemapas::mapa_comunas\n\nnombres_comunas <- chilemapas::codigos_territoriales |> select(matches(\"comuna\"))\n\n# mapa de la región metropolitana\nmapa <- mapa_comunas |> \n  # especificar la geometría\n  st_set_geometry(mapa_comunas$geometry) |> \n  # agregar nombres de comunas\n  left_join(nombres_comunas, by = \"codigo_comuna\") |> \n  # filtrar la región metropolitana\n  filter(codigo_region == \"13\")\n\nmapa\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 52 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -71.71523 ymin: -34.29093 xmax: -69.76999 ymax: -32.92194\nGeodetic CRS:  SIRGAS 2000\n# A tibble: 52 × 5\n   codigo_comuna codigo_provincia codigo_region                         geometry\n * <chr>         <chr>            <chr>                       <MULTIPOLYGON [°]>\n 1 13404         134              13            (((-70.61396 -33.73862, -70.609…\n 2 13402         134              13            (((-70.61396 -33.73862, -70.623…\n 3 13124         131              13            (((-70.75679 -33.38348, -70.780…\n 4 13103         131              13            (((-70.72154 -33.43661, -70.724…\n 5 13301         133              13            (((-70.37256 -33.10578, -70.376…\n 6 13303         133              13            (((-70.72028 -32.95297, -70.723…\n 7 13302         133              13            (((-70.79191 -33.17296, -70.783…\n 8 13107         131              13            (((-70.59589 -33.33656, -70.590…\n 9 13104         131              13            (((-70.68968 -33.36587, -70.682…\n10 13504         135              13            (((-71.27576 -33.40409, -71.263…\n# ℹ 42 more rows\n# ℹ 1 more variable: nombre_comuna <chr>\n```\n\n\n:::\n:::\n\n\n\nPodemos ver que obtuvimos un _dataframe_ donde cada fila es una comuna, individualizada por su nombre y su código único territorial (`codigo_comuna`). \n\nEn esta tabla de datos, la columna `geometry` contiene la información geográfica de cada comuna, lo que permite visualizarlas como un mapa. \n\nPor lo tanto, en cada fila tenemos información geográfica que representa polígonos comunales, donde cada polígono (o conjuto de polígonos) se corresponde con los datos existentes en las demás columnas, que pueden ser información como sus nombres, su población, o cualquier otra.\n\n\n## Visualización\n\n### Mapa básico de la región\n\nPodemos visualizar este mapa de manera con `{ggplot2}`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa |> \n  # iniciar gráfico\n  ggplot() +\n  # agregar capa con el mapa\n  geom_sf(fill = \"grey60\", col = \"white\") +\n  # tema\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_prueba-1.png){width=768}\n:::\n:::\n\n\nObtuvimos un mapa básico de todas las comunas de la Región Metropolitana de Santiago. \n\n\n### Mapa de la región con datos ficticios\n\nAhora, hagamos una prueba para aprender a visualizar datos en la di este mapa. Para esto, crearemos una nueva variable donde algunas comunas tengan valores distintos. Podemos crear la nueva variable a partir de la columna `nombre_comuna`, aunque siempre es preferible hacerlo en base a la columna `codigo_comuna`, dado que los códigos únicos territoriales son identificadores únicos para cada comuna, mientras que los nombres de las comunas son más impredecibles (por ejemplo, pueden venir sin tilde, pueden venir en mayúsculas, o derechamente mal escritos).\n\nUsamos la función `case_when()` para asignar valores ficticios sobre algunas comunas, y los visualizamos en el mapa:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_datos <- mapa |> \n  # crear una variable para comunas específicas\n  mutate(variable = case_when(nombre_comuna == \"Paine\" ~ \"Bacán\",\n                              nombre_comuna == \"Buin\" ~ \"Penca\",\n                              nombre_comuna == \"La Florida\" ~ \"Bacán\",\n                              nombre_comuna == \"Cerrillos\" ~ \"Bacán\",\n                              nombre_comuna == \"Nunoa\" ~ \"Penca\")) |> \n  select(nombre_comuna, codigo_comuna, variable, geometry)\n\nmapa_datos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 52 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -71.71523 ymin: -34.29093 xmax: -69.76999 ymax: -32.92194\nGeodetic CRS:  SIRGAS 2000\n# A tibble: 52 × 4\n   nombre_comuna codigo_comuna variable                                 geometry\n   <chr>         <chr>         <chr>                          <MULTIPOLYGON [°]>\n 1 Paine         13404         Bacán    (((-70.61396 -33.73862, -70.60917 -33.7…\n 2 Buin          13402         Penca    (((-70.61396 -33.73862, -70.62304 -33.7…\n 3 Pudahuel      13124         <NA>     (((-70.75679 -33.38348, -70.78087 -33.4…\n 4 Cerro Navia   13103         <NA>     (((-70.72154 -33.43661, -70.72426 -33.4…\n 5 Colina        13301         <NA>     (((-70.37256 -33.10578, -70.37609 -33.1…\n 6 Tiltil        13303         <NA>     (((-70.72028 -32.95297, -70.72329 -32.9…\n 7 Lampa         13302         <NA>     (((-70.79191 -33.17296, -70.7833 -33.18…\n 8 Huechuraba    13107         <NA>     (((-70.59589 -33.33656, -70.59023 -33.3…\n 9 Conchali      13104         <NA>     (((-70.68968 -33.36587, -70.68201 -33.3…\n10 Maria Pinto   13504         <NA>     (((-71.27576 -33.40409, -71.26337 -33.4…\n# ℹ 42 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# visualizar\nmapa_datos |> \n  ggplot() +\n  aes(fill = variable) + #usamos la variable que creamos como relleno de las comunas\n  geom_sf(col = \"white\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_fill_manual-1.png){width=768}\n:::\n:::\n\n\n\n### Agregar datos obtenidos desde internet al mapa\n\nAhora, pasaremos a usar datos reales sobre nuestro mapa comunal. Pero en vez de entregarles datos copiados y pegados, obtendremos directamente los datos desde internet, [usando el paquete `{rvest}`](/blog/tutorial_scraping_rvest/) que sirve para hacer [web scraping](/blog/r_introduccion/web_scraping/) desde páginas web; es decir, descargar datos presentes en sitios de internet para usarlos directamente en R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rvest)\n\ntabla_comunas <- session(\"https://es.wikipedia.org/wiki/Anexo:Comunas_de_Chile\") |> # sitio web que scrapearemos\n  read_html() |> # leemos el contenido del sitio web \n  html_table() # extraemos las tablas del sitio web\n\ntabla_comunas_2 <- tabla_comunas[[1]] |> # elegimos la primera tabla obtenida\n  clean_names() # limpiamos los nombres de la tabla usando {janitor}\n\ntabla_comunas_3 <- tabla_comunas_2 |> \n  filter(region == \"Metropolitana de Santiago\") # filtrar la región\n\ntabla_comunas_4 <- tabla_comunas_3 |>\n  # convertir los códigos comunales a texto\n  rename(codigo_comuna = 1) |> \n  mutate(codigo_comuna = as.character(codigo_comuna))\n\ndatos_comunas <- tabla_comunas_4 |> \n  # limpiar variables numéricas para estén disponibles en formato numérico en vez de como texto\n  mutate(poblacion2020 = str_remove(poblacion2020, \" \"), # borrar espacios\n         poblacion2020 = as.numeric(poblacion2020)) |>  # transformar texto a numérico\n  # corregir superficie\n  mutate(superficie_km2 = str_remove(superficie_km2, \"\\\\.\"), # borrar puntos separadores de miles\n         superficie_km2 = str_replace(superficie_km2, \",\", \".\"), # reemplazar comas por puntos\n         superficie_km2 = as.numeric(superficie_km2)) |> # transformar texto a numérico\n  # corregir densidad\n  mutate(densidad_hab_km2 = str_remove_all(densidad_hab_km2, \"\\\\.\"), # borrar puntos separadores de miles\n         densidad_hab_km2 = str_replace(densidad_hab_km2, \",\", \".\"), # reemplazar comas por puntos\n         densidad_hab_km2 = as.numeric(densidad_hab_km2)) # transformar texto a numérico\n\ndatos_comunas\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52 × 12\n   codigo_comuna nombre      x     provincia region superficie_km2 poblacion2020\n   <chr>         <chr>       <lgl> <chr>     <chr>           <dbl>         <dbl>\n 1 13101         Santiago    NA    Santiago  Metro…            232        503147\n 2 13102         Cerrillos   NA    Santiago  Metro…             21         88956\n 3 13103         Cerro Navia NA    Santiago  Metro…             11        142465\n 4 13104         Conchalí    NA    Santiago  Metro…            107        139195\n 5 13105         El Bosque   NA    Santiago  Metro…            142        172000\n 6 13106         Estación C… NA    Santiago  Metro…             15        206792\n 7 13107         Huechuraba  NA    Santiago  Metro…            448        112528\n 8 13108         Independen… NA    Santiago  Metro…              7        142065\n 9 13109         La Cisterna NA    Santiago  Metro…             10        100434\n10 13110         La Florida  NA    Santiago  Metro…            702        402433\n# ℹ 42 more rows\n# ℹ 5 more variables: densidad_hab_km2 <dbl>, idh_2005 <chr>, idh_2005_2 <chr>,\n#   latitud <chr>, longitud <chr>\n```\n\n\n:::\n:::\n\n\n\nAsí quedó el resultado de nuestro web scraping. A continuación, [usamos la función `left_join()`](/blog/left_join/) para adjuntar estas columnas nuevas a nuestro data frame que contiene los nombres y códigos de las comunas, además de la geometría o información geográfica de las comunas, usando como columna de unión los códigos comunales:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_datos_2 <- mapa |> \n  left_join(datos_comunas, by = \"codigo_comuna\")\n\nglimpse(mapa_datos_2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 52\nColumns: 16\n$ codigo_comuna    <chr> \"13404\", \"13402\", \"13124\", \"13103\", \"13301\", \"13303\",…\n$ codigo_provincia <chr> \"134\", \"134\", \"131\", \"131\", \"133\", \"133\", \"133\", \"131…\n$ codigo_region    <chr> \"13\", \"13\", \"13\", \"13\", \"13\", \"13\", \"13\", \"13\", \"13\",…\n$ geometry         <MULTIPOLYGON [°]> MULTIPOLYGON (((-70.61396 -..., MULTIPOL…\n$ nombre_comuna    <chr> \"Paine\", \"Buin\", \"Pudahuel\", \"Cerro Navia\", \"Colina\",…\n$ nombre           <chr> \"Paine\", \"Buin\", \"Pudahuel\", \"Cerro Navia\", \"Colina\",…\n$ x                <lgl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ provincia        <chr> \"Maipo\", \"Maipo\", \"Santiago\", \"Santiago\", \"Chacabuco\"…\n$ region           <chr> \"Metropolitana de Santiago\", \"Metropolitana de Santia…\n$ superficie_km2   <dbl> 820, 214, 197, 11, 9712, 653, 452, 448, 107, 3935, 69…\n$ poblacion2020    <dbl> 82766, 109641, 253139, 142465, 180353, 21477, 126898,…\n$ densidad_hab_km2 <dbl> 1009.0, 512.3, 1284.9, 12951.3, 185.7, 328.0, 280.7, …\n$ idh_2005         <chr> \"0.718\", \"0.731\", \"0.735\", \"0.683\", \"0.726\", \"0.709\",…\n$ idh_2005_2       <chr> \"Alto\", \"Alto\", \"Alto\", \"Medio\", \"Alto\", \"Alto\", \"Med…\n$ latitud          <chr> \"-33°48'43.2\\\"\", \"-33°43'40.8\\\"\", \"-33°26'0\\\"\", \"-33°…\n$ longitud         <chr> \"-70°43'22.8\\\"\", \"-70°44'20.4\\\"\", \"-70°43'0\\\"\", \"-70°…\n```\n\n\n:::\n:::\n\n\n\nLo que hicimos en la operación anterior fue [unir dos tablas distintas en base a una variable común](/blog/left_join/) que ambas tablas poseen: `codigo_comuna`. De este modo, obtenemos un nuevo data frame que contiene tanto la información geográfica como los datos comunales que necesitamos. \n\nHabiendo hecho esto, ahora podemos crear gráficos comunales usando cualquier variable que queramos, siempre y cuando podamos hacer coincidir los datos con el mapa en base a los códigos comunales o los nombres de comuna.\n\n### Visualizar datos\n\n#### Mapa comunal de población\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_datos_2 |> \n  ggplot() +\n  geom_sf(aes(geometry = geometry, fill = poblacion2020),\n          col = \"white\") +\n  viridis::scale_fill_viridis(labels = label_number(big.mark = \".\", decimal.mark = \",\")) +\n  theme_void() +\n  labs(fill = \"Población\")\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_fill_continuo-1.png){width=768}\n:::\n:::\n\n\n\n#### Mapa comunal del índice de desarrollo humano\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_datos_2 |> \n  ggplot() +\n  geom_sf(aes(geometry = geometry, \n              fill = idh_2005_2),\n          col = \"white\") +\n  scale_fill_manual(breaks = c(\"Medio\", \"Alto\", \"Muy alto\"),\n                    values = c(\"Medio\" = \"olivedrab4\", \"Alto\" = \"olivedrab3\", \"Muy alto\" = \"olivedrab2\")) +\n  geom_sf_text(aes(geometry = geometry, label = nombre_comuna), check_overlap = T, size = 2) +\n  theme_void() +\n  labs(fill = \"IDH\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_fill_categorico-1.png){width=768}\n:::\n:::\n\n\n\nSin embargo, podemos ver que estos mapas no se ajustan perfectamente a la imagen mental que tiene un ciudadano común acerca de cómo se ve la Región Metropolitana. Por ejemplo, vemos cómo la comuna de San José de Maipo abarca una superficie enorme dado que limita en la cordillera de los Andes con Argentina, o que comunas como Lo Barnechea se expanden hacia superficies cordilleranas de gran extensión.\n\nEsto se debe a que ususalmente nos encontramos frente a mapas que representan el \"Gran Santiago\", es decir, sólo la superficie urbana de las comunas urbanas de la región, omitiendo sectores rurales, cordilleranos o deshabitados.\n\nPor lo tanto, a continuación veremos cómo obtener un mapa urbano de la Región Metropolitana de Santiago.\n\n\n## Mapa urbano de la región Metropolitana\n\nEn los siguientes pasos, pasaremos de un mapa comunal a un mapa comunal urbano; es decir, un mapa que **sólo considere la superficie urbana de las comunas**, en vez de la superficie total de las comunas. \n\nUsando `{chilemapas}`, podemos obtener un mapa de la Región Metropolitana con un nivel de detalle mayor, que divide internamente las comunas en superficies más pequeñas que sólo corresponden a zonas urbanas:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# obtener mapa por zonas rural/urbano\nmapa_zonas_urbanas <- chilemapas::mapa_zonas |> \n  # definir geometrías\n  st_set_geometry(chilemapas::mapa_zonas$geometry) |>\n  # filtrar región\n  filter(codigo_region == 13) |> \n  # agregar nombres de comunas\n  left_join(chilemapas::codigos_territoriales |> \n              select(matches(\"comuna\")))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(codigo_comuna)`\n```\n\n\n:::\n\n```{.r .cell-code}\n# mapa de zonas urbanas\nmapa_zonas_urbanas |> \n  ggplot(aes(geometry = geometry)) +\n  geom_sf(fill = \"grey60\", color = \"white\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_zonas-1.png){width=768}\n:::\n:::\n\n\n\nPodemos mejorar esta visualización **uniendo** con `st_union()` las zonas urbanas intra-comunales en sus respectivas comunas, para volver a obtener un mapa comunal, pero que recorta las comunas para que sólo consideren su la superficie urbana de cada una: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mapa de zonas urbanas\nmapa_zonas_urbanas |> \n  # unir polígonos por comunas\n  group_by(nombre_comuna, codigo_comuna) %>% \n  summarise(geometry = st_union(geometry), .groups = \"drop\") |>\n  # visualizar\n  ggplot() +\n  geom_sf(fill = \"grey60\", color = \"white\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_zonas_comunas-1.png){width=768}\n:::\n:::\n\n\n\nDe inmediato, podemos ver que emerge una figura más familiar de lo que es el _Gran Santiago,_ pero ahora tenemos otro problema: el mapa también contiene las zonas urbanas de comunas menos céntricas de la región, tales como Buin, Curacaví, Talagante y otras. Esto se debe a que nuestro mapa aún contiene comunas que no son mayoritariamente urbanas, dado que poseen sectores despoblados o de actividad agrícola, minera u otras, y que por consiguiente dan una apariencia discontinua a nuestro mapa.\n\nPara resolver esto y dejar sólo las comunas urbanas del Gran Santiago, tenemos varias opciones: podemos filtrar específicamente las comunas que queremos, o bien, podemos filtrar en base a privincias, dejando sólo las provincias Santiago y Cordillera.\n\n#### Definir contorno urbano por comunas exactas\n\n**Opción 1:** seleccionar específicamente las comunas que queremos incluir: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncomunas_urbanas <- c(\"Pudahuel\", \"Cerro Navia\", \"Conchali\", \"La Pintana\", \"El Bosque\", \n                     \"Estacion Central\", \"Pedro Aguirre Cerda\", \"Recoleta\", \"Independencia\", \n                     \"La Florida\", \"Penalolen\", \"Las Condes\", \"Lo Barnechea\", \"Quinta Normal\", \n                     \"Maipu\", \"Macul\", \"Nunoa\", \"Puente Alto\", \"Quilicura\", \"Renca\", \n                     \"San Bernardo\", \"San Miguel\", \"La Granja\", \"Providencia\", \"Santiago\",\n                     \"San Joaquin\", \"Lo Espejo\", \"La Reina\", \"San Ramon\", \"La Cisterna\", \n                     \"Lo Prado\", \"Cerrillos\", \"Vitacura\", \"Huechuraba\",\n                     \"San Jose de Maipo\")\n\n# mapa de sectores urbanos, de comunas urbanas\nmapa_zonas_urbanas |> \n  # filtrar comunas urbanas\n  filter(nombre_comuna %in% comunas_urbanas) |>\n  # unir polígonos por comunas\n  group_by(nombre_comuna, codigo_comuna) %>% \n  summarise(geometry = st_union(geometry)) |> \n  # graficar\n  ggplot() +\n  geom_sf(fill = \"grey60\", color = \"white\") +\n  theme_void()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'nombre_comuna'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_urbano_opcion1-1.png){width=768}\n:::\n:::\n\n\n\n#### Definir contorno urbano en base a provincias\n\n**Opción 2:** seleccionar las dos provincias que conforman el Gran Santiago, y agregar los ajustes que sean necesarios (incluir San Bernardo, excluir Pirque)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_zonas_urbanas |> \n  # dejar solo dos provincias, incluir San Bernardo y sacar Pirque\n  filter(codigo_provincia %in% c(131, 132) | nombre_comuna == \"San Bernardo\", nombre_comuna != \"Pirque\") |>\n  # unir polígonos por comunas\n  group_by(nombre_comuna, codigo_comuna) %>% \n  summarise(geometry = st_union(geometry)) |> \n  # graficar\n  ggplot() +\n  geom_sf(fill = \"grey60\", color = \"white\") +\n  theme_void()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'nombre_comuna'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_urbano_opcion2-1.png){width=768}\n:::\n:::\n\n\n\nLa decisión que tomes depende de los objetivos del usuario y de tu visualzación, pero dejo ambas aproximaciones a modo de aprendizaje.\n\n### Excluir islas urbanas\nLuego de haber seleccionado las comunas urbanas que necesitamos, notamos que aún quedan algunas \"islas urbanas\" fuera de la zona principal del Gran Santiago. Usualmente vemos los mapas del Gran Santiago como una sola unidad geográfica contínua, sin separaciones ni islas a su alrededor. Por lo tanto, vamos a eliminar estos elementos externos a la superficie urbana contínua de forma manual.\n\nPara identificar los polígonos que queramos remover, podemos visualizar una fracción del mapa y agregar etiquetas para dar con sus códigos geográficos, y así poder excluirlos. Por ejemplo, aquí lo haremos con Pudahuel:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa_zonas_urbanas |>\n  filter(nombre_comuna == \"Pudahuel\") |>\n  ggplot() +\n  geom_sf(fill = \"lightblue\", color = \"white\") +\n  geom_sf_text(aes(label = geocodigo), color = \"black\", size = 3) +\n  theme_void()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in st_point_on_surface.sfc(sf::st_zm(x)): st_point_on_surface may not\ngive correct results for longitude/latitude data\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/prueba_islas-1.png){width=768}\n:::\n:::\n\n\n\nBastaría con anotar los geocódigos para filtrarlos.\n\nEntonces, en el siguiente paso removeremos estas pequeñas zonas urbanas de forma manual para obtener un mapa más contínuo.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vector con geocódigos que deseamor remover\nislas_urbanas <- c(\"13124071004\", \"13124071005\", \"13124081001\", \"13124071001\", \"13124071002\", \"13124071003\", #Pudahuel\n                   \"13401121001\", #San Bernardo\n                   \"13119131001\", #Maipú\n                   \"13203031000\", \"13203031001\", \"13203031002\", \"13203011001\", \"13203011002\" #San José de Maipo\n)\n\n# crear nuevo mapa\nmapa_urbano <- mapa_zonas_urbanas |> \n  # filtrar solo comunas urbanas\n  filter(nombre_comuna %in% comunas_urbanas) |>\n  # filtrar islas urbanas\n  filter(!geocodigo %in% islas_urbanas) |>\n  # unir comunas\n  group_by(nombre_comuna, codigo_comuna) %>%\n  summarise(geometry = st_union(geometry)) |>\n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'nombre_comuna'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\n# simplificar bordes del mapa (opcional)\n# mutate(geometry = rmapshaper::ms_simplify(geometry,  keep = 0.4))\n\n# graficar\nmapa_urbano |> \n  ggplot() +\n  geom_sf(fill = \"blueviolet\", color = \"white\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/remover_islas-1.png){width=768}\n:::\n:::\n\n\nDe esta forma ya logramos graficar un mapa del Gran Santiago mucho más definido y limpio.\n\n### Visualizar datos en el mapa urbano\nTeniendo este mapa, procedemos a visualizar nuestros datos tal como hicimos al principio de este tutorial:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# volvemos a adjuntar los datos que descargamos usando web scraping, esta vez al mapa nuevo\nmapa_urbano_2 <- mapa_urbano |> \n  left_join(datos_comunas, by = \"codigo_comuna\")\n\nmapa_urbano_2 |> \n  ggplot() +\n  aes(fill = densidad_hab_km2) +\n  geom_sf(col = \"white\") +\n  viridis::scale_fill_viridis(labels = label_number(big.mark = \".\", decimal.mark = \",\"),\n                              option = \"magma\") +\n  theme_void() +\n  labs(fill = \"Densidad poblacional\")\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_urbana_fill_continuo-1.png){width=768}\n:::\n:::\n\n\n\nFinalmente, podemos poner nuestro nuevo mapa urbano de la Región Metropolitana de Santiago sobre el mapa de la región completa:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = mapa,\n          fill = \"grey95\", color = \"white\", linewidth = 0.5) +\n  geom_sf(data = mapa_urbano_2,\n          aes(fill = poblacion2020),\n          color = \"white\", linewidth = 0.2) +\n  viridis::scale_fill_viridis(labels = label_number(big.mark = \".\", decimal.mark = \",\"), \n                              option = \"mako\") +\n  theme_void() +\n  labs(fill = \"Población\") +\n  guides(fill = guide_colourbar(position = \"inside\")) +\n  theme(legend.position.inside = c(.1, .7),\n        legend.key.width = unit(3, \"mm\"),\n        legend.key.height = unit(10, \"mm\"),\n        legend.ticks.length = unit(0.4, \"mm\"))\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_urbana_fill_continuo_contexto-1.png){width=768}\n:::\n:::\n\n\nTambién podemos recortar el mapa con `coord_sf()` para hacerle un poco de zoom a la zona urbana dentro del contexto de la región completa:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_sf(data = mapa,\n          aes(geometry = geometry),\n          fill = \"grey90\", color = \"white\", linewidth = 0.4) +\n  geom_sf(data = mapa_urbano_2,\n          aes(geometry = geometry, fill = poblacion2020),\n          color = \"white\", linewidth = 0.2) +\n  coord_sf(xlim = c(-70.95, -70.33), \n           ylim = c(-33.75, -33.2), \n           expand = F) +\n  viridis::scale_fill_viridis(labels = label_number(big.mark = \".\", decimal.mark = \",\"),\n                              option = \"mako\") +\n  theme_void() +\n  labs(fill = \"Población\") +\n  theme(legend.position.inside = c(.1, .7),\n        legend.key.width = unit(3, \"mm\"),\n        legend.key.height = unit(10, \"mm\"),\n        legend.ticks.length = unit(0.4, \"mm\"))\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/region_urbana_fill_continuo_contexto_zoom-1.png){width=768}\n:::\n:::\n\n\n\n----\n\n\n\n{{< cafecito >}}\n\n\n{{< cursos >}}\n",
    "supporting": [
      "index.markdown_strict_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}