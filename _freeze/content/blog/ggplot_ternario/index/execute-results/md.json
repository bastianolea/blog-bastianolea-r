{
  "hash": "721b8a538dad45b91307fc5380e06e9b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Gráficos ternarios o triangulares de tres variables en `{ggplot2}`\nauthor: Bastián Olea Herrera\ndate: '2026-01-28'\nfreeze: true\nslug: []\ncategories: []\ntags:\n  - visualización de datos\nformat:\n  hugo-md:\n    output-file: index\n    output-ext: md\nexcerpt: \"Un gráfico ternario es una visualización de datos que representa tres variables numéricas dentro de un triángulo. En este post usaremos el paquete `{ggtern}` para crearlos con R y `{ggplot2}`.\"\nexecute: \n  warning: false\nlinks:\n  - icon: registered\n    icon_pack: fas\n    name: ggtern\n    url:  https://www.rdocumentation.org/packages/ggtern/versions/4.0.0\n---\n\nUn **gráfico ternario** es una visualización de datos que representa tres variables numéricas dentro de un triángulo. En este post usaremos el paquete `{ggtern}` para crearlos con R y `{ggplot2}`.\n\n{{< aviso \"**Post en construcción!** A medida que voy aprendiendo iré complementando.\" >}}\n\nPrimero instalamos el paquete:\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggtern\")\n```\n:::\n\n\n\n## Gráfico ternario básico\n\nVeamos lo más básico de este tipo de diagramas. Necesitamos tres variables numéricas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- tibble(x = 33,\n                y = 33,\n                z = 33)\n```\n:::\n\n\nPara visualizarlas dentro de un triángulo, usamos la función `ggtern()` en vez de `ggplot()`, y definimos las tres variables en `aes()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggtern)\n\ndatos |> \n  ggtern() +\n  aes(x = x,\n      y = y,\n      z = z) +\n  geom_point(size = 4, alpha = 0.7)\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-4-1.png){width=768}\n:::\n:::\n\n{{< info \"Aparentemente `{ggtern}` sobreescribe y cambia varias cosas del funcionamiento interno de `{ggplot2}, por lo que puede que provoque problemas o incompatibilidades. Recuerda que si tienes problemas, siempre se puede **Reiniciar R** desde el menú _Session_ de RStudio.\" >}}\n\nComo las tres variables tienen el mismo valor, el punto queda en el centro del triángulo.\n\nSi cambiamos los datos levemente, vemos que el punto se representa dentro del triángulo **como si los vértices ejercieran una atracción**. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- tibble(x = 20,\n                y = 30,\n                z = 60)\n\ndatos |> \n  ggtern() +\n  aes(x = x,\n      y = y,\n      z = z) +\n  geom_point(size = 4, alpha = 0.7)\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-5-1.png){width=768}\n:::\n:::\n\n\nEsto se debe a que, como se trata de tres variables, no pueden representarse exactamente como sí podrían en un plano cartesiano, sino que **los valores son escalados entre 0 y 100**. En este sentido, los valores que aparecen en los ejes refieren al porcentaje de la variable con respecto a las demás.\n\nPor ejemplo, si hacemos que una variable concentre el 100%, el punto aparecerá exactamente en el vértice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- tibble(x = 0,\n                y = 100,\n                z = 0)\n\ndatos |> \n  ggtern() +\n  aes(x = x,\n      y = y,\n      z = z) +\n  geom_point(size = 8, alpha = 0.7)\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n\nPero lo mismo va a pasar si la suma de las tres variables no es 100, dado que, como dijimos, las variables se escalan.\n\nSi los ejes resultan distractores para la interpretación visual del gráfico, se pueden ocultar:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- tibble(x = 33,\n                y = 33,\n                z = 33)\n\ndatos |> \n  ggtern() +\n  aes(x = x,\n      y = y,\n      z = z) +\n  geom_point(size = 4, alpha = 0.7) +\n  ggtern::theme_hideticks() +\n  ggtern::theme_hidelabels()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n\n### Visualizar tres variables\n\nTeniendo una tabla de datos con tres variables, las mapeamos en `aes()` y obtenemos sus posiciones dentro del triángulo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- tibble(x = c(10, 30, 60, 20, 40, 80),\n                y = c(30, 60, 20, 40, 30, 10),\n                z = c(60, 20, 20, 40, 30, 10),\n                grupo = c(\"B\", \"B\", \"A\", \"B\", \"A\", \"A\"))\n\ndatos |> \n    ggtern() +\n  aes(x = x,\n      y = y,\n      z = z,\n      shape = grupo,\n      color = x) +\n  geom_point(size = 4, alpha = 0.8) +\n  theme_linedraw() +\n  ggtern::theme_hideticks() +\n  ggtern::theme_hidelabels()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-8-1.png){width=768}\n:::\n:::\n\n\nEn este ejemplo podemos ver que los valores del grupo A tienen mayor valor en la variable `x` que los del grupo `b`, los cuales a su vez tienen mayor valor de `z`.\n\n### Visualizar una trayectoria\n\nSi tenemos datos que cuentan con mediciones consecutivas, podemos graficar una línea que va pasando por todos sus valores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- tibble::tribble(\n                ~año,  ~a, ~b, ~c,\n                 2013, 41.68, 44.98, 50.62,\n                 2014, 41.75, 44.18, 50.19,\n                 2015, 42.58, 45.19, 49.70,\n                 2016, 42.91, 46.61, 51.27,\n                 2017, 43.60, 48.17, 51.40,\n                 2018, 43.91, 48.71, 50.68,\n                 2019, 44.35, 48.52, 49.55,\n                 2020, 43.70, 46.53, 47.33,\n                 2021, 44.84, 51.60, 50.65,\n                 2022, 46.62, 53.56, 49.30,\n                 2023, 47.13, 50.73, 49.65,\n                 2024, 47.32, 50.94, 48.93,\n                 2025, 47.53, 50.86, 48.78,\n                )\n\ndatos |> \n  ggtern() +\n  aes(x = a,\n      y = b,\n      z = c,\n      color = año,\n      linewidth = año) +\n  geom_line(lineend = \"round\") +\n  ggtern::theme_hideticks() +\n  ggtern::theme_zoom_center(.4) +\n  scale_color_continuous(labels = scales::label_number(big.mark = \"\", \n                                                       accuracy = 1)) +\n  scale_linewidth_continuous(range = c(0.4, 1.9),\n                             labels = scales::label_number(big.mark = \"\", \n                                                           accuracy = 1)) +\n  theme_bw() +\n  ggtern::theme_hideticks() +\n  ggtern::theme_hidelabels() +\n  guides(color = guide_legend()) +\n  labs(x = \"A\", y = \"B\", z = \"C\")\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-9-1.png){width=768}\n:::\n:::\n\n\nEn este gráfico podemos ver que la unidad de información empieza con alto valor de `C`, el cual va disminuyendo en la medida que aumenta su valor de `B` y levemente aumenta su valor de `A`, terminando en una posición más balanceada.\n\n\n## Agregar un fondo en degradado\n\nEsto lo encontré demasiado bonito! Para explicar mejor la relación de atracción o proporcionalidad entre las tres variables, podemos pensarlo como un espectro de colores, donde cada variable tiene un color. De esta forma se puede expresar mejor la idea de que la posición de los puntos es una proporción entre los valores de las tres variables, una especie de mezcla entre ellas.\n\nPara crear un fondo creamos la siguiente función, que toma tres colores y crea una matriz de valores que, al mapearse en el triángulo, generarán un degradado.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# función para crear fondo degradado en gráfico ternario\nggtern_degradado <- function(color_x = \"#FF6B6B\",\n                             color_y = \"#4ECDC4\",\n                             color_z = \"#FFE66D\",\n                             resolucion = 150) {\n  \n  # crear grilla de fondo\n  fondo <- expand.grid(\n    x = seq(0, 1, length.out = resolucion),\n    y = seq(0, 1, length.out = resolucion)\n  )\n  \n  # calcular z y filtrar puntos fuera del triángulo\n  fondo <- fondo |> \n    mutate(z = 1 - x - y) |> \n    filter(x >= 0, y >= 0, z >= 0, \n           x <= 1, y <= 1, z <= 1)\n  \n  # convertir colores a RGB\n  rgb_x <- col2rgb(color_x) / 255\n  rgb_y <- col2rgb(color_y) / 255\n  rgb_z <- col2rgb(color_z) / 255\n  \n  # interpolar colores\n  fondo$color <- rgb(\n    fondo$x * rgb_x[1] + fondo$y * rgb_y[1] + fondo$z * rgb_z[1],\n    fondo$x * rgb_x[2] + fondo$y * rgb_y[2] + fondo$z * rgb_z[2],\n    fondo$x * rgb_x[3] + fondo$y * rgb_y[3] + fondo$z * rgb_z[3]\n  )\n  \n  return(fondo)\n}\n```\n:::\n\n\nEjecutamos la función con los tres colores que elijamos, y obtendremos una matriz de valores con sus coordenadas y respectivos colores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfondo <- ggtern_degradado(color_x = \"#FF6B6B\",\n                          color_y = \"#4ECDC4\",\n                          color_z = \"#FFE66D\",\n                          resolucion = 200)\n\nhead(fondo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            x y         z   color\n1 0.000000000 0 1.0000000 #FFE66D\n2 0.005025126 0 0.9949749 #FFE56D\n3 0.010050251 0 0.9899497 #FFE56D\n4 0.015075377 0 0.9849246 #FFE46D\n5 0.020100503 0 0.9798995 #FFE46D\n6 0.025125628 0 0.9748744 #FFE36D\n```\n\n\n:::\n:::\n\n\nLuego usamos esos datos para llenar de puntos el triángulo! Debido a la gran cantidad de puntos y sus cambios leves de colores, se crea un degradado suave:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtern() +\n  aes(x = x, y = y, z = z) +\n  # fondo con degradado\n  geom_point(data = fondo, \n             aes(x = x, y = y, z = z),\n             color = fondo$color) +\n  theme_bw() +\n  ggtern::theme_hideticks() +\n  ggtern::theme_hidelabels()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-12-1.png){width=768}\n:::\n:::\n\n\nPara aclarar los colores del fondo podemos usar la función `col_lighter()` de `{scales}`, como detallamos en el [post sobre colores en `{ggplot2}`](/blog/colores/):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfondo <- fondo |> \n  mutate(color = scales::col_lighter(color, 10))\n\nggtern() +\n  geom_point(data = fondo, \n             aes(x = x, y = y, z = z),\n             color = fondo$color) +\n  theme_bw() +\n  ggtern::theme_hideticks() +\n  ggtern::theme_hidelabels()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-13-1.png){width=768}\n:::\n:::\n\n\nFinalmente podemos agregar los datos en otra capa de `geom_point()` sobre el fondo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos <- data.frame(\n  x = c(0.2, 0.4, 0.3, 0.5, 0.2, 0.5, 0.4, 0.3, 0.2, 0.4),\n  y = c(0.3, 0.2, 0.4, 0.2, 0.3, 0.2, 0.4, 0.3, 0.5, 0.2),\n  z = c(0.5, 0.4, 0.3, 0.2, 0.4, 0.3, 0.2, 0.4, 0.2, 0.3)\n)\n\ndatos |> \n  ggtern() +\n  aes(x = x, y = y, z = z) +\n  # fondo con degradado\n  geom_point(data = fondo, \n             aes(x = x, y = y, z = z),\n             color = fondo$color) +\n  # datos\n  geom_point(size = 2.5, alpha = 0.6) +\n  theme_bw() +\n  ggtern::theme_hideticks() +\n  ggtern::theme_hidelabels()\n```\n\n::: {.cell-output-display}\n![](index.markdown_strict_files/figure-markdown_strict/unnamed-chunk-14-1.png){width=768}\n:::\n:::\n\n\n\n## Referencias\n\n- Hamilton NE, Ferry M (2018). “ggtern: Ternary Diagrams Using ggplot2.”\n_Journal of Statistical Software, Code Snippets_, *87*(3), 1-17.\ndoi: [10.18637/jss.v087.c03](https://doi.org/10.18637/jss.v087.c03)\n- Claude Sonnet 4.5 (para la función de fondo degradado)\n\n\n\n::: {.cell}\n\n:::\n\n\n",
    "supporting": [
      "index.markdown_strict_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}