{
  "hash": "3830951f5558adb4b60b8f9833f71496",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Crea planillas de Excel con formato personalizado desde R con {openxlsx}\"\nauthor: Bastián Olea Herrera\ndate: '2025-08-08'\nslug: []\ncategories: []\ndraft: false\nfreeze: true\ntags:\n  - limpieza de datos\n  - procesamiento de datos\n  - automatización\n  - tablas\nexcerpt: El paquete `{openxlsx}` nos entrega funciones para generar archivos Excel desde R que contengan todo tipo de formato, estilo de tablas, y manipulación celda por celda del archivo resultante, con lo que podemos generar planillas de Excel atractivas desde R. La gracia es que podremos usar estas herramientas de forma reproducible (poder re-hacer gratis la planilla con datos actualizados o corregidos), y también podremos combinar la programación de R para crear estilos condicionales, crear cientos de archivos Excel, o planillas de cientos de hojas, y mucho más.\n---\n\n\n\nAl terminar el procesamiento o limpieza de un conjunto de datos, usualmente necesitamos _entregar_ la base en un formato más amigable para otros colegas o usuarios/as, lo que significa: Excel. Exportar datos de R a Excel es fácil: con la función `writexl::write_xlsx()` podemos guardar cualquier dataframe en Excel. Pero esta función hace sólo eso, y el archivo resultante es básico y hasta feo.\n\nSin embargo, existe el [paquete `{openxlsx}`](https://ycphs.github.io/openxlsx/), que además de leer y escribir archivos Excel, nos entrega funciones para generar archivos Excel desde R que contengan **todo tipo de formato, estilo de tablas, y manipulación celda por celda** del archivo resultante, con lo que podemos **generar planillas de Excel atractivas desde R.**\n\nLa gracia es que podremos usar estas herramientas de forma reproducible (poder re-hacer gratis la planilla con datos actualizados o corregidos), y también podremos combinar la programación de R para crear **estilos condicionales**, crear **cientos de archivos Excel**, o **planillas de cientos de hojas**, y mucho más.\n\n----\n\nCarguemos un conjunto de datos de indicadores de calidad de vida urbana de Chile, del [Sistema de Indicadores y Estándares de Desarrollo Urbano](https://github.com/bastianolea/siedu_indicadores_urbanos).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(arrow)\n\ndatos <- read_parquet(\"https://github.com/bastianolea/siedu_indicadores_urbanos/raw/main/datos/siedu_indicadores_desarrollo_urbano.parquet\")\n\ndatos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,701 × 12\n   codigo_comuna codigo_region codigo_provincia nombre_region nombre_provincia\n           <dbl> <chr>         <chr>            <chr>         <chr>           \n 1          1107 01            011              Tarapacá      Iquique         \n 2          1107 01            011              Tarapacá      Iquique         \n 3          1107 01            011              Tarapacá      Iquique         \n 4          1107 01            011              Tarapacá      Iquique         \n 5          1107 01            011              Tarapacá      Iquique         \n 6          1107 01            011              Tarapacá      Iquique         \n 7          1107 01            011              Tarapacá      Iquique         \n 8          1107 01            011              Tarapacá      Iquique         \n 9          1107 01            011              Tarapacá      Iquique         \n10          1107 01            011              Tarapacá      Iquique         \n# ℹ 6,691 more rows\n# ℹ 7 more variables: nombre_comuna <chr>, id <chr>, año <dbl>, variable <chr>,\n#   valor <dbl>, medida <chr>, estandar <chr>\n```\n\n\n:::\n:::\n\n\n\nFiltremos los datos para dejar tres indicadores, y sólo los valores más recientes para cada unidad territorial.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndatos <- datos |> \n  # filtrar variables\n  filter(variable %in% c(\"Distancia a plazas públicas\",\n                         \"Número de víctimas mortales en siniestros de tránsito por cada 100.000 habitantes\",\n                         \"Porcentaje de cobertura de la red de ciclovía sobre la red vial\")) |> \n  # dejar sólo valores más recientes por comuna\n  group_by(nombre_region, nombre_comuna, variable) |>\n  filter(año == max(año)) |>\n  ungroup()\n\ndatos |> select(-starts_with(\"codigo\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 340 × 9\n   nombre_region      nombre_provincia nombre_comuna id      año variable  valor\n   <chr>              <chr>            <chr>         <chr> <dbl> <chr>     <dbl>\n 1 Tarapacá           Iquique          Alto Hospicio BPU_…  2018 Distanc… 275.  \n 2 Tarapacá           Iquique          Alto Hospicio DE_28  2021 Número …   9.70\n 3 Tarapacá           Iquique          Alto Hospicio EA_93  2021 Porcent…   1.46\n 4 La Araucanía       Malleco          Angol         BPU_…  2018 Distanc… 342.  \n 5 La Araucanía       Malleco          Angol         DE_28  2021 Número …  12.4 \n 6 La Araucanía       Malleco          Angol         EA_93  2021 Porcent…   4.59\n 7 Antofagasta        Antofagasta      Antofagasta   BPU_…  2018 Distanc… 426.  \n 8 Antofagasta        Antofagasta      Antofagasta   DE_28  2021 Número …   7.84\n 9 Antofagasta        Antofagasta      Antofagasta   EA_93  2021 Porcent…   2.74\n10 Arica y Parinacota Arica            Arica         BPU_…  2018 Distanc… 324.  \n# ℹ 330 more rows\n# ℹ 2 more variables: medida <chr>, estandar <chr>\n```\n\n\n:::\n:::\n\n\n\nAhora pivotemos los datos para crear una típica tabla de Excel donde los indicadores estén en columnas hacia el lado, mientras que hacia abajo están las unidades u observaciones; en este caso, comunas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\ndatos <- datos |> \n  select(nombre_region, nombre_comuna, codigo_comuna, variable, valor) |> \n  pivot_wider(names_from = variable, values_from = valor) |> \n  arrange(codigo_comuna)\n\ndatos |> select(-starts_with(\"codigo\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 117 × 5\n   nombre_region nombre_comuna   Distancia a plazas púb…¹ Número de víctimas m…²\n   <chr>         <chr>                              <dbl>                  <dbl>\n 1 Tarapacá      Iquique                             282.                   3.52\n 2 Tarapacá      Alto Hospicio                       275.                   9.70\n 3 Antofagasta   Antofagasta                         426.                   7.84\n 4 Antofagasta   Calama                              274.                   8.28\n 5 Atacama       Copiapó                             245.                   8.66\n 6 Atacama       Tierra Amarilla                     289.                  41.7 \n 7 Atacama       Vallenar                            241.                  12.2 \n 8 Coquimbo      La Serena                           303.                   6.29\n 9 Coquimbo      Coquimbo                            291.                  10.3 \n10 Coquimbo      Ovalle                              275.                  18.0 \n# ℹ 107 more rows\n# ℹ abbreviated names: ¹​`Distancia a plazas públicas`,\n#   ²​`Número de víctimas mortales en siniestros de tránsito por cada 100.000 habitantes`\n# ℹ 1 more variable:\n#   `Porcentaje de cobertura de la red de ciclovía sobre la red vial` <dbl>\n```\n\n\n:::\n:::\n\n\n\nSi guardamos este archivo con `{writexl}`, obtenemos una planilla básica de Excel:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(writexl)\n\nwrite_xlsx(datos, \"indicadores.xlsx\")\n```\n:::\n\n\n\n{{< imagen \"openxlsx_0.png\">}}\n\nEste resultado puede ser suficiente para algo rápido, pero definitivamente no es algo presentable ni atractivo.\n\n## Crear planillas Excel personalizadas con `{openxlsx}`\n\nEl primer paso para crear nuestro Excel es crear la planilla con la función `createWorkbook()`. Esta función se asigna a un objeto que representará a nuestra planilla.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(openxlsx)\n\ntabla <- createWorkbook()\n```\n:::\n\n\n\nIremos aplicando distintas funciones de `{openxlsx}` sobre este objeto `tabla` para ir modificando la planilla Excel resultante.\n\nCon nuestra planilla creada, tenemos que crear una _hoja_ de Excel para que podamos ponerle datos a la planilla.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddWorksheet(tabla, \"Hoja\")\n```\n:::\n\n\n\nPodemos usar esta función una o varias veces para crear una o varias hojas en nuestra planilla.\n\n\n### Guardar la planilla Excel\nEn cualquier momento del proceso puedes guardar la planilla como archivo Excel para previsualizar como está quedando tu tabla, aunque en este paso del tutorial nuestra planilla está vacía.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# guardar\nsaveWorkbook(tabla, \n             \"indicadores.xlsx\",\n             overwrite = TRUE)\n```\n:::\n\n\n\n\n### Escribir datos en la hoja de Excel\nAhora tenemos que rellenar la planilla con datos con la función `writeDataTable()`, a la que hay que especificarle primero la planilla que vamos a editar (`tabla`), y la hoja (`\"Hoja\"`) en que queremos escribir los datos. En el argumento `x` entregamos el dataframe que queremos escribir en la hoja de la planilla.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tabla con formato personalizado\nwriteDataTable(tabla, \"Hoja\",\n               x = datos,  # la tabla que queremos escribir en el Excel\n               tableStyle = \"TableStyleLight9\", # estilo de la tabla\n               startRow = 1, startCol = 1,\n               colNames = TRUE,\n               bandedCols = TRUE,\n               bandedRows = FALSE,\n               withFilter = FALSE, \n               # keepNA = TRUE, \n               # na.string = \"sin datos\"\n)\n```\n:::\n\n\n\nEsta función tiene varios argumentos que permiten personalizar la planilla. El más relevante es `tableStyle`, con el que le damos uno de los temas de Excel a la tabla. Podemos encontrar los temas de Excel en el botón _Dar formato como tabla_ del panel _Inicio_ de Excel.\n\n\n\n{{< imagen \"openxlsx_1.png\" >}}\n\n\n\n\nEn este panel, si pones el cursor sobre los íconos puedes ver que cada estilo tiene un número (9 es una tabla azul con fila de encabezado, 13 es la misma pero morada, 5 es una tabla celeste con encabezado sin relleno, etc.), y una intensidad (_claro, medio_ y _oscuro_)\n\n\n\n{{< imagen \"openxlsx_2.png\" >}}\n\n\n\n\nAsí va quedando nuestra planilla!\n\n### Modificar ancho de columnas\n\nSi tenemos columnas que requieren más ancho, podemos definirlo con `setColWidths()`. En esta y otras funciones de `{openxlsx}`, en el argumento `cols` le decimos qué columnas queremos afectar, y luego le decimos el valor que queremos darle a cada columna correspondiente.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ancho de columnas\nsetColWidths(tabla, \"Hoja\",\n             cols = c(1, 2, 3,\n                      4, 5, 6),\n             widths = c(22, 22, 13,\n                        30, 30, 30)\n)\n```\n:::\n\n\n\nEn este ejemplo, afectamos las 6 columnas: a las 1 y 2 le damos `22` de ancho, luego a la 3 le damos `13`, y a las tres finales (columnas con los indicadores) les damos un mayor ancho de `30`.\n\n\n\n{{< imagen \"openxlsx_3.png\" >}}\n\n\n\n\nSi el texto aún no cabe en las celdas, podemos **definir un estilo** a las celdas para que el texto se corte y aumente el alto de las celdas con mucho texto. Para definir un estilo usamos `addStyle()` y le damos un estilo que se hace con `createStyle()`. Luego, se define las filas (`rows`) y columnas (`cols`) que recibirán este estilo.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# flujo de texto \naddStyle(tabla, \"Hoja\",\n         style = createStyle(wrapText = TRUE), \n         rows = 1:nrow(datos)+1, \n         cols = c(1, 4, 5, 6), \n         stack = TRUE, gridExpand = T)  \n```\n:::\n\n\n\nEn este caso le puse que las filas a las que se aplica el estilo sean todas las filas del dataframe (`nrow(datos)`) más `1`, porque recordemos que en Excel la fila de los nombres de columna cuenta como una fila. Por eso el estilo se aplica desde la fila `1` a la `nrow(datos)+1`.\n\n\n\n{{< imagen \"openxlsx_4.png\" >}}\n\n\n\n\n### Definir estilo de texto\n\nAhora quiero que las primeras dos columnas vayan en negrita. Hacemos lo mismo que en el paso anterior, pero ahora creamos un estilo distinto con `createStyle()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# celdas en negrita\naddStyle(tabla, \"Hoja\",\n         style = createStyle(textDecoration = \"BOLD\"), \n         rows = 1:nrow(datos)+1, \n         cols = c(1, 2), \n         stack = TRUE, gridExpand = T)\n```\n:::\n\n\n\nEs importante definir los argumentos `stack = TRUE, gridExpand = T` para que los estilos se sumen en vez de reemplazarse.\n\n\n\n{{< imagen \"openxlsx_5.png\" >}}\n\n\n\n\nNotamos que, cuando el texto de las celdas _fluye_ para usar múltiples líneas, los valores quedan alineados verticalmente hacia abajo, y se ven feos, así que los alinearemos verticalmente en el centro:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# centrado vertical\naddStyle(tabla, \"Hoja\",\n         style = createStyle(valign = \"center\"),\n         rows = 1:nrow(datos)+1, \n         cols = 1:length(datos), \n         stack = TRUE, gridExpand = T)\n```\n:::\n\n\n\nNótese que aplicamos este estilo a todas las filas (`1:nrow(datos)+1`) y a todas las columnas `1:length(datos)`.\n\n\n\n{{< imagen \"openxlsx_6.png\" >}}\n\n\n\n\n\n### Formatear variables numéricas\n\nLos números con decimales pueden ser ajustados definiendo el estilo `createStyle(numFmt = \"0.00\")` o similar, donde el texto representa la cantidad de decimales que queremos mostrar:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# decimales\naddStyle(tabla, \"Hoja\",\n         style = createStyle(numFmt = \"0.00\"), \n         rows = 1:nrow(datos)+1, cols = c(6),\n         stack = TRUE, gridExpand = TRUE)\n\naddStyle(tabla, \"Hoja\",\n         style = createStyle(numFmt = \"0.0\"), \n         rows = 1:nrow(datos)+1, cols = c(4, 5),\n         stack = TRUE, gridExpand = TRUE)\n```\n:::\n\n{{< imagen \"openxlsx_7.png\" >}}\n\n\n\n\n\n### Estilo condicional de celdas de acuerdo a los valores de los datos\n\nComo hemos visto hasta ahora, todos los estilos se aplican definiendo la posición de las filas y columnas que queremos modificar. Por ejemplo, si queremos modificar la cuarta fila de la segunda columna, sería `rows = 4, cols = 2`.\n\nPodemos aprovechar esta lógica para aplicar estilos que dependan del valor de los datos.\n\nPor ejemplo, si tenemos un vector de datos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos[[4]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]  282.38  274.86  425.99  273.83  245.02  288.62  241.10  303.18  291.29\n [10]  275.40  698.60  331.96  337.03 1014.74  487.85  422.81  195.91  258.19\n [19]  335.53  349.64  692.08  463.75  383.77  579.18  418.08  326.72  533.01\n [28]  629.13 1066.37  394.09  193.46  341.26  309.32  271.24  237.21  626.54\n [37]  196.91  261.74  243.70  277.05  250.93  334.88  260.42  298.01  397.34\n [46]  630.78  278.38  250.96  269.13  361.94  842.69  174.37  268.58  241.55\n [55]  249.80  242.14  405.63  342.34  269.90  211.65  459.62  203.42  223.62\n [64]  302.26  355.57  241.34  207.37  198.72  260.57  271.98  264.33  325.99\n [73]  379.62  206.06  218.95  196.25  442.02  330.57  475.15  213.77  197.15\n [82]  238.16  170.11  349.66  260.62  219.73  345.05  185.01  206.69  344.91\n [91]  260.17  216.00  252.60  429.94  224.27  444.36  187.97  692.96  708.93\n[100]  263.33  302.88  519.54  220.60  303.81  489.65  327.53  335.11  196.11\n[109]  385.91  468.69  255.61  313.70  385.68  323.99  232.25  313.80  288.51\n```\n\n\n:::\n:::\n\n\n\nPodemos evaluar una comparación para ver qué valores cumplen o no; en este caso, qué valores son superiores a `400`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos[[4]] > 400\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n [13] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE\n [25]  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n [49] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n [61]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n [97] FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE\n[109] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\nAhora que sabemos qué valores cumplen, con la función `which()` podemos obtener su posición:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(datos[[4]] > 400)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   3  11  14  15  16  21  22  24  25  27  28  29  36  46  51  57  61  77  79\n[20]  94  96  98  99 102 105 110\n```\n\n\n:::\n:::\n\n\n\nEs decir, obtenemos un vector que dice en qué filas se cumple la condición. Teniendo esto, podemos crear formatos condicionales según los datos: creamos un estilo con `createStyle()` que defina un relleno, borde y color de borde, **que se aplique solamente a las celdas donde se cumple la condición**, pero sumándole 1 para saltarnos la primera fila (nombres de columnas en Excel).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# color condicional\naddStyle(tabla, \"Hoja\",\n         # crear estilo de color de relleno\n         style = createStyle(fgFill = \"#E6B8B7\",\n                             border = c(\"top\", \"bottom\"),\n                             borderColour = c(\"#DA9694\", \"#DA9694\")),\n         # filas a las que se va a aplicar el estilo\n         rows = which(datos[[4]] > 400)+1, # celdas donde x es mayor a 400, + 1 para saltarse la primera fila\n         cols = 4, \n         stack = TRUE, gridExpand = T)\n\n# otro estilo para otra columna\naddStyle(tabla, \"Hoja\",\n         style = createStyle(fgFill = \"#E6B8B7\",  \n                             border = c(\"top\", \"bottom\"),\n                             borderColour = c(\"#DA9694\", \"#DA9694\")),\n         rows = which(datos[[5]] > 10)+1, \n         cols = 5, \n         stack = TRUE, gridExpand = T)\n\n# un tercer estilo con colores distintos\naddStyle(tabla, \"Hoja\",\n         style = createStyle(fgFill = \"#D7E4BC\",\n                             border = c(\"top\", \"bottom\"),\n                             borderColour = c(\"#C4D79B\", \"#C4D79B\")),\n         rows = which(datos[[6]] > 5)+1, \n         cols = 6, \n         stack = TRUE, gridExpand = T)\n```\n:::\n\n\n\nEn este ejemplo aplicamos tres estilos condicionales a tres columnas distintas, cada uno con un criterio personalizado para destacar celdas con valores que cumplen la condición apropiada.\n\n\n\n{{< imagen \"openxlsx_8.png\" >}}\n\n\n\n\n\nCuando estemos satisfechxs con nuestra planilla, la guardamos como Excel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# guardar\nsaveWorkbook(tabla, \n             \"indicadores.xlsx\",\n             overwrite = TRUE)\n```\n:::\n\n\n\n\n### Otros\nAquí voy a ir dejando otras funcionalidades útiles de `{openxlsx}`:\n\nDefinir el tamaño que tendrá la ventana al abrir la planilla\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tamaño de la ventana\nsetWindowSize(tabla,\n              yWindow = 12, xWindow = 12,\n              windowWidth = \"20000\",\n              windowHeight = \"15000\")\n```\n:::\n\n\n\nCambiar la altura de las celdas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# altura para celdas con texto\nsetRowHeights(tabla, \"Hoja\",\n              rows = c(6, 7, 12, 13),\n              heights = c(64, 64, 64))\n```\n:::\n\n\n\n----\n\n## Otros tutoriales:\n\n- [Creating Professional Excel Reports with R: A Comprehensive Guide to openxlsx Package](https://www.r-bloggers.com/2024/11/creating-professional-excel-reports-with-r-a-comprehensive-guide-to-openxlsx-package/)\n- [Making pretty Excel files in R](https://guslipkin.medium.com/making-pretty-excel-files-in-r-46a15c7a2ee8)\n\n----\n\n\n\n{{< cafecito >}}\n\n\n{{< cursos >}}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}