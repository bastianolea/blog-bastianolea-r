{
  "hash": "4f7ec53fdb45aca37c43b798adde2270",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Crear y conectarse a una base de datos Postgres en R\nauthor: Basti√°n Olea Herrera\ndate: '2025-11-06'\ndraft: false\nfreeze: true\nslug: []\ncategories:\n  - Tutoriales\ntags:\n  - datos\n  - optimizaci√≥n\n  - dplyr\nformat:\n  hugo-md:\n    output-file: index\n    output-ext: md\nexcerpt: \"Coloquialmente se usa el t√©rmino _base de datos_ para referirse a datos que est√°n en Excel. Pero en realidad una base de datos es algo distinto: un sistema de almacenamiento y procesamiento de datos que puede contener m√∫ltiples tablas, alojado en un computador, servidor o en la nube, que puede entregar datos de forma r√°pida y eficiente de acuerdo a las solicitudes que se le hagan. En este post veremos c√≥mo crear una base de datos gratuita, c√≥mo conectarnos a ella desde R, a leer y escribir tablas, y procesar datos desde la base de datos remota.\"\n---\n\n\n{{< indice >}}\n\n## Qu√© es una base de datos\n\nCuando se habla de datos, mucha gente (me incluyo) usa coloquialmente el t√©rmino _base de datos_ para referirse a datos que est√°n en Excel o `csv` üò£ Pero la realidad es que una base de datos es algo distinto: un **sistema de almacenamiento y procesamiento de datos** que puede contener m√∫ltiples tablas, que est√° _hosteado_ en un computador, servidor o en la nube, y que entrega datos de acuerdo a las solicitudes que se le hagan. En este sentido **una base de datos es distinto a _leer_ un archivo**, porque la base de datos siempre tiene _cargados_ los datos, y est√° esperando que se los pidan para entregarlos de manera optimizada. \n\nUna de las diferencias principales al usar bases de datos es que **no necesitas _cargar_ los datos** en tu computador, porque se encuentran en la base de datos remota. En vez de cargarlos, los puedes **solicitar** para que la base los procese y te los entregue. Solamente cuando los necesitas en memoria, los cargas localmente.\n\nPero adem√°s, una base de datos puede hacer m√°s que simplemente almacenar los datos. Las solicitudes que hacemos a la base, usualmente hechas por medio del lenguaje SQL, son **procesadas de forma r√°pida y eficiente**, entreg√°ndote solamente lo necesario. De este modo puedes acceder a conjuntos de **muchos millones de observaciones** sin que tu computador explote üí•\n\n\n## Cu√°ndo usar una base de datos\n\n- Cuando la **cantidad de observaciones es muy grande**, y te encuentras con l√≠mites de memoria\n- Cuando necesitas **acceder a los datos desde varios equipos o aplicaciones**\n- Cuando tus datos **ocupan mucho almacenamiento local** y preferir√≠as que estuvieran en la nube\n- Cuando tienes muchos datos, y solo los cargas para obtener subconjuntos o res√∫menes de los mismos\n- Cuando quieres **optimizar la velocidad** de acceso a los datos, sobre todo la velocidad de cargar archivos\n- Cuando tienes un conjunto de datos complejos que requieren de **m√∫ltiples tablas relacionadas entre s√≠**\n- Cuando no puedes mantener todos los datos en memoria\n\nA continuaci√≥n veremos c√≥mo **crear** una base de datos gratuita, c√≥mo **conectarnos** a ella desde R, y c√≥mo subir y trabajar con los datos en la base de datos remota.\n\n----\n\n## Crear una base de datos en Supabase\n\nComo una base de datos requiere estar instalada en un computador o servidor, necesitamos un proveedor que nos permita alojar la base de datos[^1]. Una opci√≥n es [Supabase](https://supabase.com), una plataforma para bases de datos que se basa en c√≥digo abierto, y que ofrece **bases de datos Postgres gratuitas** para proyectos peque√±os.\n\n[^1]: Tambi√©n se puede correr la base de datos en tu mismo computador, pero eso lo dejamos para otro post ü§ì\n\nPara empezar, [crea una cuenta en Supabase](https://supabase.com/dashboard/sign-up).\n\nUna vez en tu cuenta, en la secci√≥n _**Projects**_, crea un nuevo proyecto:\n\n{{< imagen \"supabase_1.png\" >}}\n\nUn proyecto es una instancia en el servidor de Supabase con su propia **base de datos Postgres**[^2], donde podr√°s escribir tus tablas de datos. Ponle un nombre y define una contrase√±a segura. Con esta contrase√±a podr√°s acceder a tus datos.\n\n[^2]: Postgres es un sistema de gesti√≥n de bases de datos relacionales , uno de los m√°s usados, pero existen muchos otros m√°s, como SQLite, MariaDB, y m√°s.\n\n{{< imagen \"supabase_2.png\" >}}\n\nLuego de crear el proyecto se abrir√° el panel principal, donde te indica que (por ahora) tienes cero tablas üëéüèª\n\n\n## Conectarse a la base de datos \n\nCon el proyecto creado, ahora podemos conectarnos a la base de datos. Pero necesitamos crear una conexi√≥n con la misma, y para ello requerimos ciertas credenciales y datos para que tu computador conecte con el servidor donde est√° tu base de datos.\n\nPresiona _**Connect**_ en la parte superior. para ver los par√°metros de conexi√≥n.\n\n{{< imagen \"supabase_3.png\" >}}\n\nSe abrir√° un panel donde se nos entregar√°n los **par√°metros de acceso** a la base de datos. Presiona _View parameters_ para desplegar la informaci√≥n:\n\n{{< imagen \"supabase_5.png\" >}}\n\nNecesitamos los par√°metros `host`, `port`, `database` y `user`. Ahora iremos a R para introducirlos y conectarnos.\n\n### Credenciales de acceso\n\nPara interactuar con bases de datos, necesitamos el paquete `{DBI}`, que gestiona las conexiones con bases de datos, y en nuestro caso el paquete `{RPostgres}`, que es el motor para trabajar con bases de datos Postgres.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"DBI\")\ninstall.packages(\"RPostgres\")\n```\n:::\n\n\nPara conectarnos a una base de datos desde R usamos la funci√≥n `dbConnect()`. Dentro de esta funci√≥n explicitamos el _driver_ de la base de datos (en este caso `Postgres()`), y los par√°metros de conexi√≥n que obtuvimos en Supabase: `dbname`, `host`, `port`, `user` y `password`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndb_con <- DBI::dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = \"host\",\n  port = 5432,\n  user = \"postgres\",\n  password = \"contrase√±a\"\n  )\n```\n:::\n\n\n‚ö†Ô∏è ¬°Pero espera! **No es seguro escribir credenciales privadas en un script.** As√≠ que vamos a seguir las _buenas pr√°cticas_ y vamos a **guardar las credenciales de forma segura**.\n\nUna opci√≥n es no escribir la contrase√±a y en su lugar usar `rstudioapi::askForPassword()` para ingresar la contrase√±a manualmente pero de forma segura. Sin embargo, no queremos estar escribiendo la contrase√±a cada vez que necesitemos los datos!\n\n### Variables de entorno\nVamos a crear un script donde podamos guardar **variables de entorno**, que son variables que R puede leer pero que **no quedan en el c√≥digo**, y que adem√°s **siempre se cargan cuando abrimos el proyecto**. Es decir, quedan disponibles para poder usarlas, pero estar√°n ocultas. As√≠ podemos compartir y respaldar nuestro c√≥digo sin exponer informaci√≥n sensible, y podemos conectarnos a la base de datos sin tener que volver a introducir las credenciales.\n\n**Creamos un script de entorno** llamado `.Renviron` en la ra√≠z de nuestro proyecto ejecutando una funci√≥n que lo hace por nosotres:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::edit_r_environ(scope = \"project\")\n```\n:::\n\n\nEn el script que se abre **guardamos las credenciales** de la siguiente manera:\n\n```\ndb_host=db.blablablabla.supabase.co\ndb_port=5432\ndb_user=postgres\ndb_pass=clavebasededatosprueba\n```\n\nUna vez guardadas las credenciales, **reiniciamos la sesi√≥n de R** para que se lean las variables de entorno (siempre se leer√°n al iniciar R), o podemos ejecutar `readRenviron(\".Renviron\")` para cargarlas.\n\n\n{{< aviso \"**‚ö†Ô∏è Importante:** Si usas [git](/tags/git/), no olvides agregar el archivo `.Renviron` a tu `.gitignore` para evitar subir a internet credenciales privadas!\" >}}\n\n### Conexi√≥n a la base de datos\n\nProcedemos a hacer la conexi√≥n a la base de datos de forma segura, usando `Sys.getenv()` para obtener las variables de entorno que guardamos en `.Renviron`:\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(RPostgres)\n\ndb_con <- DBI::dbConnect(\n  RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = Sys.getenv(\"db_host\"),\n  port = Sys.getenv(\"db_port\"),\n  user = Sys.getenv(\"db_user\"),\n  password = Sys.getenv(\"db_pass\")\n)\n```\n:::\n\n\nAl conectarnos creamos un objeto que representa nuestra conexi√≥n a la base de datos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndb_con\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<PqConnection> postgres@db.ybqnpazmjvictxbevqqk.supabase.co:5432\n```\n\n\n:::\n:::\n\n\nUsaremos este objeto para interactuar con la base de datos.\n\n## Crear una tabla en la base de datos\n\nCon la funci√≥n `dbWriteTable()` creamos en la base de datos una tabla nueva a partir de un dataframe; por ejemplo, usando el conjunto de datos `iris` que viene por defecto en R.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\n\n# crear tabla\ndbWriteTable(conn = db_con, # conexi√≥n a la base\n             name = \"prueba\", # nombre de la tabla a crear\n             iris # datos a escribir\n             )\n```\n:::\n\n\nConfirmamos que la tabla se subi√≥ a la base de datos consult√°ndole a la base los **nombres de las tablas existentes**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(db_con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"prueba\"                  \"pg_stat_statements\"     \n[3] \"pg_stat_statements_info\"\n```\n\n\n:::\n:::\n\n\nTambi√©n podemos confirmar en Supabase que la tabla existe:\n\n{{< imagen \"supabase_6.png\" >}}\n\nAhora nuestros datos est√°n almacenados remotamente en la base de datos! Acaso √©sta ser√° la m√≠stica nube de la que tanto hablan? ‚òÅÔ∏è\n\n\n## Leer una tabla desde la base de datos\n\nPodemos leer las tablas existentes en la base de datos con `dbReadTable()` tan solo indicando el nombre de la tabla:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_db <- dbReadTable(db_con, # conexi√≥n a la base\n            \"prueba\" # nombre de la tabla a leer\n            )\n\nhead(datos_db)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\nDe esta manera solicitamos a la base que nos entregue los datos de la tabla, y los cargamos en la sesi√≥n de R como un dataframe. Desde este punto podemos usar los datos normalmente, pero a continuaci√≥n veremos una forma mejor de hacerlo ü´¢\n\n## Procesar desde la base de datos con `{dplyr}`\n\nUna de las ventajas de una base de datos es **solicitar y obtener datos procesados desde la base de datos** üè≠ Normalmente esto se hace con el lenguaje `SQL`, pero en R hay formas m√°s sencillas: [usando directamente `{dplyr}`](/tags/dplyr/) para **interactuar con la base de datos**.\n\nPara ello [instalamos `{dbplyr}`](https://dbplyr.tidyverse.org), paquete que traducir√° el c√≥digo de `{dplyr}` en SQL.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"dbplyr\")\n```\n:::\n\n\nEsta funcionalidad se carga autom√°ticamente al cargar `{dplyr}`.\n\nPara **obtener datos** desde la base de datos, usamos `tbl()` con el objeto de conexi√≥n y el nombre de la tabla, y recibiremos los datos en el formato `tibble` de `{dplyr}`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndatos_db <- tbl(db_con, \"prueba\")\n\ndatos_db\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   table<\"prueba\"> [?? x 5]\n# Database: postgres  [postgres@db.ybqnpazmjvictxbevqqk.supabase.co:5432/postgres]\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <chr>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ‚Ñπ more rows\n```\n\n\n:::\n:::\n\n\nEsta tabla generada desde la base de datos **no es un dataframe normal** üò± sino que es una **conexi√≥n abierta con la base de datos**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(datos_db)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_PqConnection\" \"tbl_dbi\"          \"tbl_sql\"          \"tbl_lazy\"        \n[5] \"tbl\"             \n```\n\n\n:::\n:::\n\n\nEsto nos permite seguir pidi√©ndole instrucciones que se procesar√°n en la base, no en nuestra sesi√≥n local de R. Esto es lo que nos permite realizar **c√°lculos con datos de grandes vol√∫menes** o **manejar bases de datos gigantes que no caben en la memoria de tu computador** üò≤\n\nUsemos la tabla obtenida desde la base de datos para hacer un filtro y calcular un promedio:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculo_db <- datos_db |> \n  filter(Species == \"setosa\") |> \n  summarise(mean_sepal_length = mean(Sepal.Length))\n```\n:::\n\n\nEstas operaciones se realizan remotamente en la base, y con una evaluaci√≥n _perezosa_ ü¶• (_lazy evaluation_); es decir, solamente se calcula el resultado cuando es estrictamente necesario. Entonces, reci√©n al solicitar el resultado **la base de datos va a realizar el c√°lculo requerido**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculo_db\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Missing values are always removed in SQL aggregation functions.\nUse `na.rm = TRUE` to silence this warning\nThis warning is displayed once every 8 hours.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 1]\n# Database: postgres  [postgres@db.ybqnpazmjvictxbevqqk.supabase.co:5432/postgres]\n  mean_sepal_length\n              <dbl>\n1              5.01\n```\n\n\n:::\n:::\n\nPodemos confirmar que el c√°lculo se hizo en la base de datos usando `show_query()` para ver el c√≥digo `SQL` que se us√≥ para hacer el c√°lculo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculo_db |> show_query()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT AVG(\"Sepal.Length\") AS \"mean_sepal_length\"\nFROM (\n  SELECT \"prueba\".*\n  FROM \"prueba\"\n  WHERE (\"Species\" = 'setosa')\n) AS \"q01\"\n```\n\n\n:::\n:::\n\nü™Ñ‚ú® Magia! Es como si hubi√©ramos aprendido SQL: combinamos el poder de SQL con la conveniencia de R.\n\nSi necesitamos _traer_ los datos desde la base a tu computador, los **cargamos en la memoria** con la funci√≥n `collect()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_df <- datos_db |> \n  filter(Species == \"setosa\") |> \n  collect()\n```\n:::\n\n\nAhora s√≠ que s√≠ el objeto `datos_df` se encuentra cargado en tu sesi√≥n local de R como un dataframe normal.\n\nComo los c√°lculos que hagamos sobre los datos se **traducen** desde R a SQL y luego se nos entregan, un uso importante de `collect()` es para anteponerlo a **operaciones que no tienen traducci√≥n a SQL**. \n\nPor ejemplo, me consta que las funciones de `{forcats}` no se traducen a SQL:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_db |> \n  group_by(Species) |> \n  summarise(Sepal.Width = mean(Sepal.Width)) |> \n  mutate(Species = forcats::fct_reorder(Species, Sepal.Width))\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `forcats::fct_reorder()`:\n! No known SQL translation\n```\n\n\n:::\n:::\n\n\nEn este caso, anteponemos `collect()` para pasar de SQL a R en medio del proceso y listo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos_db |> \n  group_by(Species) |> \n  summarise(Sepal.Width = mean(Sepal.Width)) |> \n  collect() |> # cargar a la memoria\n  mutate(Species = forcats::fct_reorder(Species, Sepal.Width)) |> \n  arrange(Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 √ó 2\n  Species    Sepal.Width\n  <fct>            <dbl>\n1 versicolor        2.77\n2 virginica         2.97\n3 setosa            3.43\n```\n\n\n:::\n:::\n\n\nDe esta forma, aprovechamos la base de datos SQL lo m√°s posible, y cuando necesitemos operaciones m√°s complejas nos pasamos a R! üòâ\n\n\n----\n\nYa sea porque necesitas la **capacidad de almacenamiento**, porque requieres **procesamiento optimizado de grandes vol√∫menes de datos**, o porque vas a **usar tus datos en una aplicaci√≥n o plataforma**, aprender a manejar bases de datos es una habilidad crucial para escalar tus capacidades y pasar al siguiente nivel ‚ú®\n\n----\n\n## Recursos\n- [A Crash Course on PostgreSQL for R Users](https://pacha.dev/blog/2020/08/09/postgresql-for-r-users/), por [Mauricio Vargas S.](https://pacha.dev)\n\n\n{{< cafecito >}}\n\n{{< cursos >}}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}