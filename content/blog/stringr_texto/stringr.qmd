---
title: 'Limpieza y recodificaci√≥n de datos de texto en R con {stringr}'
author: Basti√°n Olea Herrera
date: '2025-06-08'
draft: false
format: 
  hugo-md:
    output-file: "index"
output-ext:  "md"
slug: []
categories:
  - tutoriales
tags:
  - limpieza de datos
  - texto
excerpt: Los datos que vienen como texto suelen necesitar una limpieza previa, y adicionalmente un procesamiento para poder aprovecharlos mejor. En este tutorial usamos el paquete `{stringr}` para limpiar y ordenar unos datos de texto.
editor_options: 
  chunk_output_type: inline
---


[El paquete `{stringr}`](https://stringr.tidyverse.org/index.html) facilita todo tipo de trabajo que implique texto en R. 

En general, los datos que vienen como texto suelen necesitar una limpieza previa, y adicionalmente un procesamiento para poder aprovecharlos mejor.

Sigamos un ejemplo con una columna que viene con textos sobre compras en un servicio p√∫blico:

```{r}
#| warning: false
library(dplyr)
library(stringr) # para trabajar con textos

datos <- tibble(
  texto = c("Licitaci√≥n p√∫blica N¬∞3432",
            "Trato directo #3341",
            "Licitaci√≥n privada 876",
            "LICITACION PUBLICA N3430",
            "Licitacion publica 3526 concluida",
            "licitaci√≥n p√∫blica 2986 ok",
            "sin informaci√≥n")
)
```

```{r}
#| include: false
datos |> knitr::kable(format = "markdown")
```

|texto                             |
|:---------------------------------|
|Licitaci√≥n p√∫blica N¬∞3432         |
|Trato directo #3341               |
|Licitaci√≥n privada 876            |
|LICITACION PUBLICA N3430          |
|Licitacion publica 3526 concluida |
|licitaci√≥n p√∫blica 2986 ok        |
|sin informaci√≥n                   |

Como es de esperar, el texto viene _sucio_: escrito de distintas maneras, con y sin tildes, con y sin may√∫sculas, etc.

### Crear variable a partir de la detecci√≥n de texto

Una primera limpieza de los datos puede ser identificar si un texto espec√≠fico est√° o no presente en la variable de texto sucio. Para ello podemos usar la funci√≥n `str_detect()`, que retorna `TRUE` o `FALSE` si en el texto que se le entrega como primer argumento est√° presente el texto en su segundo argumento. Por ejemplo:


```{r}
str_detect("un texto ac√° muy feo", "feo") # s√≠ (TRUE)

str_detect("un texto ac√° muy bonito", "feo") #no (FALSE)
```

Aplicamos `str_detect()` dentro de un `mutate()` para crear una columna que indique la presencia de un texto a lo largo de la columna de texto:

```{r}
datos |> 
  mutate(licitacion = str_detect(texto, "Licitaci√≥n"))
```

Vemos que s√≥lo entrega dos `TRUE`, siendo que en las filas 4, 5 y 6 tambi√©n deber√≠a encontrar coincidencias. Esto se debe a que existen diferencias en las letras min√∫sculas y may√∫sculas.


## Cambiar la capitalizaci√≥n de un texto
Un problema com√∫n con la limpieza de texto es encontrar **diferencias en las may√∫sculas** de las palabras. `{stringr}` tiene varias funciones para ayudarnos a cambiar textos a may√∫sculas, min√∫sculas, y m√°s.

```{r}
str_to_lower("HOLA, c√≥mo est√°s?")

str_to_upper("hola, c√≥mo est√°s?!")

str_to_sentence("hola, c√≥mo est√°s?")
```

Pero a veces necesitamos corregir la capitalizaci√≥n de textos que en su interior contienen palabras que empiezan con may√∫sculas, o siglas/acr√≥nimos, en cuyo caso convertir a min√∫sculas o a oraci√≥n arruinar√≠an la gram√°tica correcta.

```{r}
# texto que no empieza con may√∫scula
texto <- "mi nombre es Cecilia y trabajo en la ONU."

# agregar may√∫scula inicial, pero se pierden las dem√°s may√∫sculas
str_to_sentence(texto)
```

En estos casos podemos realizar un reemplazo de texto con `str_replace()` que solamente reemplace la primera letra del texto por su versi√≥n may√∫scula, y deje las dem√°s intactas:

```{r}
# reemplazar s√≥lo primera letra de la primera palabra
str_replace(texto, "^.", toupper)
```

Aqu√≠ usamos una **expresi√≥n regular** (`^.`) para indicar que queremos reemplazar solamente la primera letra del texto (el s√≠mbolo `^` indica el inicio del texto, y `.` indica cualquier s√≠mbolo).

Volviendo al ejemplo de los datos, para corregir la detecci√≥n de datos con `str_detect()` cuando hay diferencias de may√∫sculas, primero convertimos el texto a min√∫sculas con `str_to_lower()`, y buscamos el t√©rmino en min√∫sculas:

```{r}
datos |> 
  mutate(licitacion = str_detect(str_to_lower(texto), "licitaci√≥n"))
```

Obtenemos una coincidencia m√°s! Pero siguen faltando dos casos (casos 4 y 5) que deber√≠an retornar `TRUE`. En estos casos, el problema est√° con **diferencias en los tildes** de las palabras. Para solucionar esto, podemos hacer una b√∫squeda de texto usando _regex_. 



## Expresiones regulares

Las [expresiones regulares o _regex_](https://stringr.tidyverse.org/articles/regular-expressions.html) son formas de escribir patrones de b√∫squeda, y son soportadas por todas las funciones de `{stringr}`. Uno de estos patrones es el operador _o_ (`|`). El operador _o_ puede usarse para encontrar coincidencias con varias palabras distintas separadas con `|`:

```{r}
str_detect(c("hola", "holo", "holi"), "hola|holi")
```

En este ejemplo, se coincide con un `TRUE` tanto el texto `hola` como `holi`. Pero en este ejemplo ambas palabras son muy similares; 75% similares, para ser exactos ü§ì‚òùüèº. Podemos poner entre par√©ntesis los caracteres espec√≠ficos que var√≠an, para que dentro de una misma palabra se acepten distintos caracteres:

```{r}
str_detect(c("hola", "holo", "holi"), "hol(a|i)")
```

De este modo, se coincide con la palabra `hol` seguida tanto de `a` como de `i`; es decir, `hola` y `holi`.

Finalmente, tambi√©n podemos pedirle que coincida una palabra que dentro de ella tenga _cualquier_ caracter:

```{r}
str_detect(c("hola", "holo", "holi"), "hol.")
```

Siguiendo estos ejemplos para volver a nuestros datos, podemos coincidir texto con y sin tildes al mismo tiempo si usamos _regex_ para especificar que uno o varios caracteres pueden ser distintos; en este caso, la letra _o_ con y sin tilde:

```{r}
datos |> 
  mutate(licitacion = str_detect(str_to_lower(texto), "licitaci(√≥|o)n"))
```

Podemos usar el mismo c√≥digo pero dentro de un `ifelse()` para que, en vez de `TRUE` y `FALSE`, retorne lo que queramos para las condicies verdadera y falsa:

```{r}
datos |> 
  mutate(licitacion = ifelse(str_detect(str_to_lower(texto), "licitaci(√≥|o)n"), 
                             yes = "Licitaci√≥n",
                             no = "Otros"))
```

Tambi√©n podemos usar el operador `.*` de _regex_ para indicar cualquier cantidad de caracteres entre el texto antes y despu√©s del operador. Por ejemplo:

```{r}
str_detect(c("hola", "hooooooola", "ho8787897la", "hola hola"), "ho.*la")
```

En el ejemplo, `ho.*la` significa coincidir con un texto que tenga `ho`, cualquier texto, y luego `la`; por lo tanto, coincide con `hola`, `hooooooola`, `ho8787897la` y cualquier otra variaci√≥n.

Podemos usar esto para hacer coincidencias m√°s flexibles:

```{r}
datos |> 
  mutate(tipo = case_when(str_detect(str_to_lower(texto), "lic.*privada") ~ "Licitaci√≥n privada",
                          str_detect(str_to_lower(texto), "lic.*p.blica") ~ "Licitaci√≥n p√∫blica",
                          str_detect(str_to_lower(texto), "trato.*directo|contra.*direct") ~ "Trato directo")
  )
```

Si combinamos los aprendizajes hasta el momento, podemos crear una columna nueva que entregue distintos valores dependiendo del texto detectado, gracias a `case_when()`:

```{r}
datos |> 
  # limpiar el texto de antemano
  mutate(texto_2 = str_to_lower(texto)) |> 
  # detectar licitaciones
  mutate(licitacion = str_detect(texto_2, "licitaci(√≥|o)n")) |> 
  # detectar si son p√∫blicas, privadas, o de otro tipo
  mutate(tipo = case_when(
    # si son licitaciones, y si contiene "privada"
    licitacion & str_detect(texto_2, "privad(o|a)") ~ "Licitaci√≥n privada",
    # si son licitaciones y si contiene "p√∫blico"
    licitacion & str_detect(texto_2, "p(√∫|u)blic(a|o)") ~ "Licitaci√≥n p√∫blica",
    # otros valores
    str_detect(texto_2, "trato directo") ~ "Trato directo",
    # todos los dem√°s que no coincidieron en las condiciones anteriores
    .default = "Otros"))
```



### Extraer caracteres desde un texto
Una √∫ltima alternativa para limpiar estos datos ser√≠a _extraer_ texto espec√≠fico desde la variable de texto. Es decir, encontrar un tipo de texto dentro de otro texto, y solamente dejar ese texto extra√≠do. Por ejemplo: entre un texto extenso, extraer solamente una palabra espec√≠fica, si es que existe, o extraer solamente los n√∫meros que est√©ndentro del texto.

Para esto podemos usar la funci√≥n `str_extract()` combinada con un operador _regex_ para extraer secuencias de n√∫meros (`\\d+`):

```{r}
datos |> 
  mutate(numero = str_extract(texto, "\\d+"))
```

----

Para finalizar, unimos todas las t√©cnicas que vimos en este ejemplo, para terminar con una tabla de datos mucho m√°s √∫til que la que ten√≠amos al inicio!

```{r}
datos_limpios <- datos |> 
  # limpiar el texto de antemano
  mutate(texto_2 = str_to_lower(texto)) |> 
  # detectar licitaciones
  mutate(licitacion = ifelse(str_detect(str_to_lower(texto), "licitaci(√≥|o)n"), 
                             yes = "Licitaci√≥n",
                             no = "Otros")) |> 
  # detectar si son p√∫blicas, privadas, o de otro tipo
  mutate(tipo = case_when(
    # si son licitaciones, y si contiene "privada"
    licitacion == "Licitaci√≥n" & str_detect(texto_2, "privad(o|a)") ~ "Licitaci√≥n privada",
    # si son licitaciones y si contiene "p√∫blico"
    licitacion == "Licitaci√≥n" & str_detect(texto_2, "p(√∫|u)blic(a|o)") ~ "Licitaci√≥n p√∫blica",
    # otros valores
    licitacion == "Otros" & str_detect(texto_2, "trato directo") ~ "Trato directo",
    # todos los dem√°s que no coincidieron en las condiciones anteriores
    .default = "Otros")) |> 
  # extraer n√∫meros
  mutate(numero = str_extract(texto, "\\d+"),
         numero = as.numeric(numero)) |> # convertir n√∫meros a num√©ricos
  # eliminar columnas innecesarias
  select(-contains("texto"))
```

```{r}
#| include: false
datos_limpios |> knitr::kable(format = "markdown")
```

|licitacion |tipo               | numero|
|:----------|:------------------|------:|
|Licitaci√≥n |Licitaci√≥n p√∫blica |   3432|
|Otros      |Trato directo      |   3341|
|Licitaci√≥n |Licitaci√≥n privada |    876|
|Licitaci√≥n |Licitaci√≥n p√∫blica |   3430|
|Licitaci√≥n |Licitaci√≥n p√∫blica |   3526|
|Licitaci√≥n |Licitaci√≥n p√∫blica |   2986|
|Otros      |Otros              |     NA|


```{r}
#| include: false
# # usar el operador "$" de regex para buscar algo que solo aparezca al final de la l√≠nea
# 
# str_detect("director", "directo$")
# str_detect(c("directo trato", "directorio", "director de", "trato directo"), "directo$")
# str_detect("directo", "directo$")
# str_detect("director de asuntos", "directo$")
# 
# 
# # coincidir usando una condici√≥n que tiene que cumplirse y otra que no tenga que cumplirse
# # as√≠ coincidimos por un criterio pero excluimos por otro, simult√°neamente
# 
# 
# tibble(tipo = c("contrato de personal",
#                 "contrataci√≥n directa",
#                 "contrato directo")) |> 
#   mutate(tipo2 = case_when(str_detect(tipo, "contrat") & !str_detect(tipo, "personal") ~ "S√≠",
#                            .default = "No"))
# 
# # coincidir usando l√≠mites de palabras (word boundary)
# 
# tibble(tipo = c("Trato directo",
#                 "TD",
#                 "TDAH",
#                 "T D")) |> 
#   mutate(tipo2 = case_when(str_detect(tolower(tipo), "trato directo") ~ "S√≠",
#                            str_detect(tipo, "\\b(TD)\\b") ~ "S√≠", # boundary
#                            str_detect(tipo, "\\bT D\\b") ~ "S√≠",
#                            .default = "No"))

```

{{< cafecito >}}