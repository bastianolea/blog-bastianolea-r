---
title: "Redactar textos basados en datos autom√°ticamente con R: describiendo resultados del censo de poblaci√≥n"
author: Basti√°n Olea Herrera
date: '2026-02-12'
slug: []
categories: []
tags:
  - texto
  - automatizaci√≥n
  - loops
  - funciones
  - g√©nero
  - Chile
format:
  hugo-md:
    output-file: index
    output-ext: md
excerpt: Luego de explorar o procesar un conjunto de datos, toca presentar los resultados. Si bien esto nos hace pensar en gr√°ficos, tablas o reportes, el texto tambi√©n es una forma de comunicar resultados que puede ser optimizada mediante la programaci√≥n. En este tutorial veremos c√≥mo redactar textos a partir de datos, incluso redactar p√°rrafos complejos que describan la informaci√≥n de m√∫ltiples observaciones, usando los resultados oficiales de las preguntas de g√©nero del Censo 2024.
editor_options: 
  chunk_output_type: console
execute:
  echo: true
  warning: false
  message: false
---


Luego de explorar o procesar un conjunto de datos, toca **presentar los resultados**. Si bien esto nos hace pensar en [gr√°ficos](/tags/visualizaci√≥n-de-datos/), [tablas](/tags/tablas/) o [reportes](/tags/quarto/), el **texto** tambi√©n es una forma de comunicar resultados que puede ser **optimizada** mediante la programaci√≥n.

En este tutorial veremos c√≥mo hacer que R redacte p√°rrafos de texto que se pueden adaptar a tus datos, ya sea adoptando la sintaxis y **redacci√≥n** apropiadas, **integrando cifras**, o escribiendo distintas oraciones de manera **condicional** a los resultados.

{{< imagen "featured.png" >}}

Empecemos con un conjunto de datos sociales: los [resultados del Censo de poblaci√≥n y vivienda 2024](https://censo2024.ine.gob.cl/resultados/) de Chile, espec√≠ficamente la **poblaci√≥n por g√©nero** en cada regi√≥n del pa√≠s.


{{< boton "Descargar datos" "blog/2026-02-12/P5_Genero.xlsx" "fas fa-file-download" >}}

{{< detalles "**Ver c√≥digo de la limpieza de los datos**" >}}

```{r}
library(dplyr)
library(janitor)
library(readxl)
library(tidyr)

# cargar
genero <- read_xlsx("P5_Genero.xlsx", sheet = 2)

# limpiar
genero_limpio <- genero |> 
  row_to_names(3) |> 
  filter(!is.na(Regi√≥n))

# transformar a largo
genero_long <- genero_limpio |> 
  pivot_longer(cols = 4:last_col(),
               names_to = "genero",
               values_to = "poblacion") |> 
  rename(total = 3)

# convertir variables y calcular porcentajes
genero_porcentaje <- genero_long |> 
  mutate(poblacion = as.numeric(poblacion),
         total = as.numeric(total)) |>
  clean_names() |>
  mutate(porcentaje = poblacion / total)

# filtrar
genero <- genero_porcentaje |> 
  filter(region != "Pa√≠s")

```

{{< /detalles >}}


Luego de limpiar estos datos, vemos columnas con las regiones del pa√≠s, la poblaci√≥n regional, los distintos g√©neros consultados en el censo, la cantidad de personas y su porcentaje:

```{r}
library(dplyr)

genero |> 
  filter(region == "Valpara√≠so")
```

## Usando datos para generar texto

Empecemos **filtrando un caso** de una regi√≥n espec√≠fica y un g√©nero determinado:

```{r}
genero_f <- genero |> 
  filter(region == "Valpara√≠so") |> 
  filter(genero == "No binario")

genero_f
```


Sabemos que podemos extraer el texto o los valores de una tabla de datos con el operador `$`, y si tenemos una tabla de una sola fila √©sto se vuelve muy conveniente:

```{r}
genero_f$genero

genero_f$poblacion
```

Podemos usar esta t√©cnica para **redactar un p√°rrafo simple**. 

La funci√≥n `glue()` del paquete `{glue}` nos permite crear textos que contengan valores de objetos de R, simplemente abriendo par√©ntesis de llave (`{` y `}`) con el c√≥digo de R dentro:

```{r}
library(glue)

glue("En la regi√≥n de {genero_f$region} existen {genero_f$poblacion} personas de g√©nero {genero_f$genero}, que representan a un {genero_f$porcentaje * 100}% de la poblaci√≥n regional.")
```

‚úçüèº Creamos una oraci√≥n que adquiere sus valores desde la tabla de datos filtrada!

Por lo tanto, si filtramos la tabla de nuevo, obtendremos un **texto que se ajuste a los nuevos datos**:

```{r}
# volver a filtrar datos
genero_f <- genero |> 
  filter(region == "Metropolitana de Santiago") |> 
  filter(genero == "Transfemenino")

# volver a redactar texto
glue("En la regi√≥n de {genero_f$region} existen {genero_f$poblacion} personas de g√©nero {genero_f$genero}, que representan a un {genero_f$porcentaje * 100}% de la poblaci√≥n regional.")
```

### Mejoras para la generaci√≥n de texto

Ahora podemos **mejorar el texto generado** usando algunas funciones que entregan formatos apropiados a las cifras y modifican otros textos.

El paquete `{scales}` cuenta con varias funciones para formatear valores. Primero definimos una configuraci√≥n por defecto con `number_options()`, y luego usamos  `number()` y `percent()` para formatear las cifras de poblaci√≥n y porcentaje.

Tambi√©n usamos `str_to_lower()` de `{stringr}` para convertir el texto del g√©nero a min√∫scula.

```{r}
library(scales)

number_options(big.mark = ".",
               decimal.mark = ",")

n <- number(genero_f$poblacion) # n√∫meros con puntos separadores de miles
p <- percent(genero_f$porcentaje, 0.01) # porcentaje con 2 decimales

library(stringr)
g <- str_to_lower(genero_f$genero) # texto a min√∫scula

# redactar texto mejorado
glue("En la regi√≥n de {genero_f$region} existen {n} personas de g√©nero {g}, que representan a un {p} de la poblaci√≥n regional.")
```


## Crear una funci√≥n que redacte texto

Ahora que tenemos unas l√≠neas de c√≥digo que hacen lo que necesitamos, podemos ponerlas dentro de una funci√≥n para poder utilizarla varias veces sin repetir tanto c√≥digo.

{{< info "Una **funci√≥n** es un c√≥digo que realiza una tarea espec√≠fica, y que puede ser reutilizado varias veces, recibiendo distintos valores de entrada. As√≠ simplificamos nuestro c√≥digo, evitamos la repetici√≥n de c√≥digo, y abrimos la posibilidad de automatizar." >}}

Para crear la funci√≥n, simplemente le damos un nombre y usamos `function()` para definir los **argumentos** que recibir√° la funci√≥n. En este caso, la funci√≥n `redactar_genero()` recibe primero los datos, y luego el argumento `region`, que es la regi√≥n para la que queremos filtrar los datos y redactar el texto.

```{r}
redactar_genero <- function(genero, region) {
  
  # filtrar la regi√≥n y el g√©nero
  genero_f <- genero |> 
    filter(region == {{region}}) |> 
    filter(genero == "No binario")
  
  # formatear cifras y valores
  n <- number(genero_f$poblacion)
  p <- percent(genero_f$porcentaje, 0.01)
  g <- str_to_lower(genero_f$genero)
  
  # elegir art√≠culo seg√∫n la regi√≥n
  art <- recode_values(genero_f$region,
                       "Biob√≠o" ~ "del",
                       "Metropolitana de Santiago" ~ "",
                       "Libertador General Bernardo O'Higgins" ~ "del",
                       "Maule" ~ "del",
                       default = "de")
  
  # redactar texto
  glue("En la **regi√≥n {art} {genero_f$region}** existen {n} personas de **g√©nero {g}**, que representan a un {p} de la poblaci√≥n regional.")
}
```

Abre que tenemos la funci√≥n, simplemente la aplicamos a la regi√≥n que deseamos:

```{r}
redactar_genero(genero, "Valpara√≠so")

redactar_genero(genero, "Metropolitana de Santiago")
```

## Redactar texto en serie usando _loops_

El mismo c√≥digo que usamos arriba, ya sea como l√≠neas de c√≥digo o como una funci√≥n, puede ser usado dentro de un _loop_ para generar m√∫ltiples veces textos que se adaptan a distintos datos.

{{< info "Un _loop_ sirve para repetir muchas veces una misma operaci√≥n, a partir de un vector con valores distintos, a cada uno de los cuales se le aplicar√° la operaci√≥n." >}}

En este caso crearemos un _loop_ con `{purrr}` y la funci√≥n `map()`, que primera recibe un vector con los elementos que queremos repetir, y la funci√≥n que le aplicaremos a cada uno de los elementos:

```{r}
library(purrr)

regiones <- unique(genero$region)

textos <- map(regiones, 
              ~redactar_genero(genero, .x)
)
```

Recibimos como resultado una lista con todos los textos para cada uno de los valores que pusimos en el _loop_.

```{r}
#| echo: false
#| output: asis
library(shiny)

textos |> 
  map(markdown) |> 
  map(tags$li) |> 
  tagList() |> 
  tags$ul()
```


{{< detalles "Otras formas de imprimir los resultados" >}}

Algunas formas de obtener estos resultados son simplemente imprimiendo la lista, o usando `cat()` para imprimir cada texto en una nueva l√≠nea, y as√≠ poder copiarlos y pegarlos en otro programa:

```{r}
textos |> 
  unlist() |> 
  cat(sep = "\n\n")
```


{{< /detalles >}}


## Redactar textos para grupos de observaciones

En el ejemplo anterior hicimos que R redacte texto extra√≠do de una sola fila de una tabla; es decir, de una sola observaci√≥n. Ahora veremos c√≥mo redactar texto que considere los **valores de varias filas de datos a la vez**.

Por ejemplo, veamos c√≥mo redactar un texto que nos resuma los **resultados del Censo en una regi√≥n completa**, considerando los valores mayores y menores, entre otros datos.

```{r}
genero_r <- genero |> 
  filter(region == "Coquimbo") |> 
  filter(genero != "Prefiere no responder/No sabe",
         genero != "Otro") |> 
  arrange(desc(poblacion))

genero_r
```

Luego de filtrar los datos para un grupo de observaciones, nos encontramos con datos para cinco filas.

Primero obtenemos el **valor del grupo filtrado**, en este caso la regi√≥n, y luego podemos **filtrar observaciones clave** que queramos destacar en el texto; en este caso, los g√©neros binarios que son mayor√≠a:

```{r}

region <- genero_r$region[1]

genero_masc <- genero_r |> 
  filter(genero == "Masculino")

genero_fem <- genero_r |> 
  filter(genero == "Femenino")

texto_general <- glue("La regi√≥n de {region} tiene una distribuci√≥n entre hombres y mujeres de {percent(genero_masc$porcentaje)} hombres y {percent(genero_fem$porcentaje)} mujeres.")

texto_general
```


### Textos condicionales seg√∫n datos

Dado que en el p√°rrafo anterior nos encontramos con porcentajes que var√≠an muy poco, agregaremos un texto donde se compare un valor espec√≠fico con un valor, generando un **texto condicional en base a los datos**. 

En este caso, escribimos un texto que explica si el porcentaje de hombres en una regi√≥n es mayor al promedio de hombres en el pa√≠s.

```{r}
# calcular promedio de hombres a nivel nacional
promedio <- genero |> 
  summarize(total = sum(poblacion), .by = genero) |> 
  mutate(porcentaje = total / sum(total)) |> 
  filter(genero == "Masculino") |>
  pull(porcentaje)

comparacion <- if_else(genero_masc$porcentaje >= promedio,
                       "mayor",
                       "menor")

texto_promedio <- glue("El porcentaje de hombres con respecto de mujeres es {comparacion} al promedio nacional de hombres.")
```

En el c√≥digo anterior, si el valor de la observaci√≥n supera al del promedio calculado, el texto dir√° _mayor_, o de lo contrario dir√° _menor_.

Ahora podemos usar alguna funci√≥n que nos permita **resumir los datos**; por ejemplo, la cantidad de **valores √∫nicos** de una variable relevante; en este caso la cantidad de g√©neros medidos por el censo:

```{r}
n_generos <- n_distinct(genero_r$genero)

texto_generos <- glue("El Censo en la regi√≥n de {region} cuenta con estad√≠sticas oficiales de {n_generos} g√©neros distintos, excluyendo no respuestas.")

texto_generos
```

Luego podemos filtrar la tabla para obtener **estad√≠sticos descriptivos** como las mayores y menores observaciones:

```{r}
genero_max <- genero_r |> slice_max(poblacion)
genero_min <- genero_r |> slice_min(poblacion)

texto_resumen <- glue("El g√©nero con mayor poblaci√≥n es {genero_max$genero} con {number(genero_max$poblacion)} personas, mientras que el con menor poblaci√≥n es {genero_min$genero}, con {number(genero_min$poblacion)}.")

texto_resumen
```

Ahora redactemos uno texto para un **subgrupo de todas las observaciones**. En este caso, redactaremos algo espec√≠fico para los g√©neros fuera del binario cis:

```{r}
cuir <- genero_r |> 
  filter(genero != "Masculino",
         genero != "Femenino")

cuir
```

Filtramos en la observaci√≥n **mayoritaria**, y luego generamos textos que **ordenen las observaciones** y las redacten como una secuencia de palabras. 

La funci√≥n `glue_collapse()` del paquete `{glue}` nos permite unir los elementos de un vector de texto, **separ√°ndolos por comas**, y convenientemente poniendo la letra _y griega_ antes del √∫ltimo elemento! As√≠, `A B C` se vuelven `A, B Y C`.

```{r}
# obtener la observaci√≥n mayoritaria
cuir_max <- cuir |> slice_max(poblacion)

# redactar valores como secuencia de palabras
cuir_gen <- glue_collapse(cuir$genero, sep = ", ", last = " y ")

# redactar cifras como secuencia de palabras
cuir_pob <- cuir$poblacion |> 
  number() |> # puntos de miles
  glue_collapse(, sep = ", ", last = " y ")

# redactar texto combinando elementos anteriores
texto_subgrupo <- glue("Aparte de masculino y femenino, los dem√°s g√©neros en la regi√≥n son {cuir_gen}, con {cuir_pob} personas respectivamente, siendo el g√©nero con mayor poblaci√≥n {cuir_max$genero} con un {percent(cuir_max$porcentaje, 0.1)} de la regi√≥n.")

texto_subgrupo
```

Finalmente, podemos **unir todas estas t√©cnicas** dentro de un _loop_ para obtener los p√°rrafos para todas las regiones del pa√≠s de manera **autom√°tica**:

```{r}
textos <- map(regiones, function(region) {
  
   # elegir art√≠culo seg√∫n la regi√≥n
  art <- recode_values(region,
                       "Biob√≠o" ~ "del",
                       "Metropolitana de Santiago" ~ "",
                       "Libertador General Bernardo O'Higgins" ~ "del",
                       "Maule" ~ "del",
                       default = "de")
  
  # filtrar datos
  genero_r <- genero |> 
    filter(region == {{region}})  |> 
    filter(genero != "Prefiere no responder/No sabe",
           genero != "Otro") |> 
    arrange(desc(poblacion))
  
  # filtrar observaciones relevantes
  genero_masc <- genero_r |> 
    filter(genero == "Masculino")
  
  genero_fem <- genero_r |> 
    filter(genero == "Femenino")
  
  texto_general <- glue("La **regi√≥n {art} {region}** tiene una distribuci√≥n entre hombres y mujeres de {percent(genero_masc$porcentaje, 0.01)} hombres y {percent(genero_fem$porcentaje, 0.01)} mujeres.")
  
  # calcular promedio de hombres a nivel nacional
  promedio <- genero |> 
    summarize(total = sum(poblacion), .by = genero) |> 
    mutate(porcentaje = total / sum(total)) |> 
    filter(genero == "Masculino") |>
    pull(porcentaje)
  
  # texto condicional seg√∫n los datos
  comparacion <- if_else(genero_masc$porcentaje >= promedio,
                         "mayor",
                         "menor")
  
  texto_promedio <- glue("En esta regi√≥n, el porcentaje de hombres con respecto de mujeres es {comparacion} al promedio nacional de hombres.")
  
  
  # contar observaciones √∫nicas
  n_generos <- n_distinct(genero_r$genero)
  
  texto_generos <- glue("El censo en la regi√≥n de {region} cuenta con estad√≠sticas oficiales de {n_generos} g√©neros distintos, excluyendo no respuestas.")
  
  # redactar textos con estad√≠sticos descriptivos
  genero_max <- genero_r |> slice_max(poblacion)
  genero_min <- genero_r |> slice_min(poblacion)
  
  texto_resumen <- glue("El g√©nero con mayor poblaci√≥n es el **{str_to_lower(genero_max$genero)}** con {number(genero_max$poblacion)} personas, mientras que el con menor poblaci√≥n es {str_to_lower(genero_min$genero)}, con {number(genero_min$poblacion)}.")
  
  # redactar textos sobre subgrupos de observaciones
  cuir <- genero_r |> 
    filter(genero != "Masculino",
           genero != "Femenino")
  
  cuir_max <- cuir |> slice_max(poblacion, with_ties = FALSE)
  
  cuir_gen <- cuir$genero |> 
    str_to_lower() |> 
    glue_collapse(sep = ", ", last = " y ")
  
  cuir_pob <- cuir$poblacion |> 
    number() |> 
    glue_collapse(, sep = ", ", last = " y ")
  
  texto_subgrupo <- glue("Aparte de masculino y femenino, los dem√°s g√©neros en la regi√≥n son {cuir_gen} con {cuir_pob} personas respectivamente, siendo **{str_to_lower(cuir_max$genero)}** el de mayor poblaci√≥n, con {number(cuir_max$poblacion)} personas en total, lo que representa un {percent(cuir_max$porcentaje, 0.1)} de la poblaci√≥n regional.")
  
  # unir todas las oraciones en un p√°rrafo
  paste(texto_general, texto_promedio, texto_generos, texto_resumen, texto_subgrupo)
})
```

Se trata de una t√©cnica que te permite tener **total control sobre la redacci√≥n** de los textos, y **completa certeza acerca de la exactitud de los datos** incluidos. Este c√≥digo se puede usar para [aplicaciones interactivas con Shiny](/tags/shiny/), para redactar [reportes de manera automatizada con Quarto](/blog/quarto_loop/), y m√°s!

Ahora veremos el resultado de obtener todos los **p√°rrafos redactados autom√°ticamente** a partir de los datos. 

Pasamos de una tabla de datos como √©sta:

```{r}
#| echo: false
genero |> 
  select(-codigo_region) |> 
  slice_sample(n = 8) |> 
  knitr::kable(format = "markdown")
```

A este texto que redacta todos los resultados üò±

```{r}
#| echo: false
#| output: asis
library(shiny)

textos |> 
  map(markdown) |> 
  map(tags$li) |> 
  tagList() |> 
  tags$ul()
```

Contemplen **LA CANTIDAD** de texto que redactamos con el c√≥digo anterior, donde no usamos nada demasiado complejo, solamente peque√±as piezas que juntas fueron armando el texto!

Imagina lo conveniente que es hacer esto si tienes que **repetir un mismo an√°lisis o descripci√≥n de datos de decenas o cientos de veces**, o si necesitas redactar texto acerca de **datos que puedan actualizarse** o que pueden ser corregidos!

{{< cafecito >}}

{{< cursos >}}