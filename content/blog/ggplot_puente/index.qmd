---
title: Gr√°ficos de puente en `{ggplot2}`
author: Basti√°n Olea Herrera
date: '2026-02-05'
slug: []
categories: []
tags:
  - visualizaci√≥n de datos
  - gr√°ficos
format:
  hugo-md:
    output-file: index
    output-ext: md
execute:  
  warning: false
excerpt: "Me pidieron reproducir con R un gr√°fico de puente que hab√≠an hecho en Excel, para poder crear decenas de versiones del mismo gr√°fico a partir de datos distintos y/o actualizados. En este post veremos c√≥mo hacer gr√°ficos de puente con R, que son gr√°ficos donde las barras representan el cambio de un valor original en el tiempo, o bien, la contribuci√≥n de varias cifras a un valor final, en la forma de barras escalonadas."
---


Me pidieron reproducir con R un **gr√°fico de puente** que hab√≠an hecho en Excel, para poder crear decenas de versiones del mismo gr√°fico a partir de datos distintos y/o actualizados.

√âste era el gr√°fico original:

{{< imagen_tama√±o "original.png" >}}

{{< bajada "El gr√°fico de puente original" >}}

Los **gr√°ficos de puente** son gr√°ficos donde las barras representan el cambio de un valor original en el tiempo, o bien, la contribuci√≥n de varias cifras a un valor final, en la forma de barras escalonadas.

Nunca hab√≠a hecho uno, y tampoco sab√≠a c√≥mo se llamaban como para buscar instrucciones, as√≠ que me puse a intentarlo!

√âstos son los datos originales:

```{r}
datos <- tibble::tribble(
  ~valor,        ~factor, ~region,    
  0.267569260593819,       "produc",       1, 
  0.658155474611586, "merc laboral",       1, 
  0.124032556711811,        "innov",       1, 
  0.346384929903161,       "empres",       1, 
  0.197669772542558,          "gob",       1, 
  0.1331561948028,          "salud",       1, 
  1.18645838429506,         "segur",       1, 
  -0.25626249726395,     "cap ingr",       1, 
  0.0845792632225653,    "igualdad",       1, 
  0.58032570060242,       "ent viv",       1, 
  0.107679485231535,      "med amb",       1, 
  0.0248454494479557,     "cap nat",       1, 
  -0.110064921904146,     "cap hum",       1, 
  0.782311601326303,      "cap fis",       1,
)
```

Lo primero que hice fue **explorar visualmente** los datos:

```{r}
library(ggplot2)

# definir un tema
theme_set(
  theme_classic(base_family = "Rubik", 
                base_size = 10,
                ink = "#2d4a6d")
)

# visualizar
datos |> 
  ggplot() +
  aes(factor, valor) +
  geom_col()
```

Luego fui pensando qu√© caracter√≠sticas ten√≠an que tener los datos para poder visualizarlos como en el gr√°fico original ü§î

## Procesamiento de datos

Lo primero que se necesita es ir **sumando los valores** consecutivamente, dado que el gr√°fico va visualizando un _puente_ donde cada barra parte desde el alto de la anterior. As√≠ que usamos la funci√≥n `cumsum()` para ir sumando los valores de cada fila con los anteriores, de manera acumulativa:

```{r}
#| message: false
library(dplyr)

datos <- datos |> 
  mutate(suma = cumsum(valor))

datos
```

Con esto obtenemos los **valores superiores** de cada barra del gr√°fico.

Despu√©s necesitamos saber los **valores inferiores** de las barras, que en este tipo de gr√°fico aparecen **encima** de las barras anteriores. Para saber esto, tomamos la suma acumulada que calculamos antes y le restamos el valor de cada una de las barras; de esta forma obtenemos el valor acumulado _menos_ el valor de la barra presente; es decir, su **base**:

```{r}
datos <- datos |> 
  mutate(base = suma - valor)

datos
```

Luego necesitamos algo simple: indicar si el valor de cada barra es **positivo o negativo**, as√≠ que usamos `ifelse()`:

```{r}
datos <- datos |> 
  mutate(direcc = if_else(valor > 0,
                          "Positivo",
                          "Negativo"))

datos
```


Ahora falta el √∫ltimo detalle: el gr√°fico original tiene una barra al final que muestra el **total** o la suma acumulada de todas las barras, pero empezando desde abajo.

Como nuestro _dataframe_ tiene una fila por cada barra, tendr√≠amos que agregar una fila nueva al final con el valor total, y con la base en cero. Para √©sto podemos usar la funci√≥n `add_row()`, a la que le podemos entregar los valores de una fila nueva, pero no escribi√©ndolos a mano, sino bas√°ndonos en los datos:

```{r}
datos <- datos |> 
  add_row(valor = sum(datos$valor),
          suma = sum(datos$valor),
          base = 0, 
          region = 1,
          factor = "total",
          direcc = "Variaci√≥n")

tail(datos)
```

Finalmente ordenamos los valores del eje horiontal en el orden que vienen en el _dataframe_, para que no aparezcan por orden alfab√©tico (el orden por defecto que le da `{ggplot2}` a las variables discretas que no est√°n ordenadas)

```{r}
datos <- datos |> 
  mutate(factor = forcats::fct_inorder(factor)) 
```


## Visualizaci√≥n 
Ahora queda hacer la visualizaci√≥n. Volvemos a probar con las barras:


```{r}
datos |> 
  ggplot() +
  aes(x = factor,
      y = valor, 
      fill = direcc) +
  geom_col() +
  guides(fill = guide_legend(position = "top"))
```
Claramente no podemos usar columnas (`geom_col()`) porque necesitamos indicar el punto de partida de cada columna en el eje vertical.

Si bien se pueden hacer rect√°ngulos con `{ggplot2}`, prefer√≠ usar **l√≠neas** con la funci√≥n `geom_segment()`, que recibe valores para _x_ e _y_, pero tambi√©n para el **final** de _x_ y el final de _y_, permitiendo longitudes personalizadas. Al final, ¬øqu√© es una columna, sino una l√≠nea gruesa? üß†

```{r}
datos |> 
  ggplot() +
  aes(x = factor,
      y = valor, 
      color = direcc) +
  geom_segment(
    aes(xend = factor,
        y = base,
        yend = suma)
  ) +
  guides(fill = guide_legend(position = "top"))
```

¬°Estamos cerca! Ahora engrosamos las l√≠neas con el argumento `linewidth` dentro de `geom_segment()`, agregamos texto con `geom_text()` que se posicione seg√∫n si es positivo o negativo, una escala de colores con `scale_color_manual()`, y algunos detalles en el tema:

```{r grafico_puente_ggplot}
#| fig-width: 7
#| fig-height: 6
#| fig-dpi: 200

datos |> 
  ggplot() +
  aes(x = factor,
      y = valor, 
      color = direcc) +
  # barras con alto personalizado
  geom_segment(
    aes(xend = factor,
        y = base,
        yend = suma),
    linewidth = 12) +
  # textos encima o debajo de barras
  geom_text(aes(y = suma,
                label = round(valor, 1),
                nudge_y = ifelse(valor > 0, 0.1, -0.1)),
            size = 3,
            show.legend = F) +
  # espaciado vertical
  scale_y_continuous(expand = expansion(c(0, 0.1))) +
  # escala de colores
  scale_color_manual(values = c("Positivo" = "#2d4a6d",
                                "Negativo" = "#b52141",
                                "Variaci√≥n" = "#668243")) +
  # leyenda
  guides(color = guide_legend(title = NULL, position = "top",
                              override.aes = list(linewidth = 6))) +
  # temas
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.title = element_blank(),
        legend.key.width = unit(2, "mm"),
        panel.grid.major.y = element_line(linetype = "dashed", linewidth = 0.2, color = "grey80"))
```

Listo! Qued√≥ id√©ntico al original, y tambi√©n m√°s elegante, pero lo m√°s importante: qued√≥ **reproducible** y listo para empaquetarse en una funci√≥n que te permita **crear cientos de estos mismos gr√°ficos** con datos distintos o actualizados.