---
title: "Herramientas básicas para programar con R"
author: Bastián Olea Herrera
date: '2024-11-16'
format: 
  hugo-md:
    output-file: "index"
    output-ext:  "md"
weight: 4
draft: true
series: "Introducción a R"
slug: []
categories: ["Tutoriales"]
tags:
  - dplyr
lang: es
excerpt: Prueba
execute: 
  error: true
  eval: false
---


## Introducción

Esta es la segunda guía introductoria para aprender el lenguaje de programación R. [En la guía anterior vimos los principios más fundamentales del lenguaje R](/blog/r_introduccion/r_basico/), para familiarizarnos con R y entender su funcionamiento básico. En esta segunda guía, seguiremos puliendo nuestros aprendizajes para poder abordar más posibilidades.


- hacer lo que necesitamos
- condicionar lo que queremos que ocurra
- hacer lo que necesitamos repetidamente

## Crear funciones
La creación de funciones nos abre las puertas a todo el mundo nuevo en el uso de R para analizar nuestros datos, dado que, una vez que te familiarizas con la creación de funciones, ya no depende solamente de las herramientas existentes, sino que empiezas a hacer tú quien crea nuevas herramientas adaptadas a tus propias necesidades.

La anterior tiene el enorme beneficio de permitirte personalizar las herramientas que utilices para analizar datos a tu forma de trabajo, a las especificidades de tus datos, y a las particularidades del proceso que estés llevando a cabo. Quizás el aspecto más satisfactorio de la creación de funciones sea poder englobar un proceso largo y complejo en una función llamada `procesar_datos()`, o poder generar un gráfico detallado y atractivo tan sólo con llamar `graficar()`! 


 
definimos el nombre, los argumentos, y en el cuerpo definimos la operación

```{r}
multiplicar_mil <- function(algo) {
  algo * 1000
}
```

apliquemos la función creada

```{r}
multiplicar_mil(4)

multiplicar_mil(23212)

multiplicar_mil(edades)
```


crear otra función

```{r}
personas <- c("basti", "paula", "catherine", "luis", "natalia", "raul")


saludar <- function(persona) {
  paste("¡hola ", persona, "!", sep = "")
}

saludar(personas)
```


otra versión más compleja de la función anterior

```{r}
saludar <- function(persona) {
  # pasar el nombre a mayúsculas
  nombre_mayuscula <- toupper(persona)
  
  # crear un saludo uniendo el texto con el argumento
  saludo <- paste("¡hola ", nombre_mayuscula, "!",
                  sep = "")
  
  # agregar un animal al azar
  saludo_animal <- paste(saludo, "tu animal va a ser", 
                         sample(animales, length(persona))
  )
  
  saludo_animal
}

saludar(personas)
```


## Control de flujo
Las estructuras de control de flujo son el conjunto de reglas que hacen que, dentro de un proceso de análisis de datos, se realicen (o no) ciertas acciones si es que condiciones específicas se cumplen, o bien, que no ocurran ciertas cosas si es que las condiciones no lo permiten. En otras palabras, es una forma de hacer que tu proceso de análisis de datos adquiera fluidez, al definir momentos en los que el flujo del procesamiento es determinado por una condición que tú defines. 

Por ejemplo: si los datos llegan en cierto estado, o con ciertas particularidades, realizar un paso extra de limpieza. Si dentro de los datos existen observaciones de ciertas características, visualizar los datos de una manera específica. Si a la tabla de datos le falta una comuna columna, crearla. Si una columna viene en un tipo que no es el esperado, convertirla al apropiado. Si ocurre un error o el resultado no es aceptable, realizar la operación de nuevo de una forma alternativa.

En la práctica, esta técnica permite crear condicionalidad en la ejecución del código usando una comparación, cuyo resultado (`TRUE`/`FALSE`) decide si el código siguiente se ejecutará o no. El código dentro de la condición sólo se ejecuta si la comparación retorna `TRUE`.


```{r}
basura <- 7000

basura

if (basura > 900) {
  # limpiar el dato porque viene en kilos en vez de toneladas
  basura <- basura /1000
  message("el valor es mayor a 900, por lo que será dividido en 1000")
} 

basura
```
en este ejemplo, creamos un flujo de control donde un dato se divide sólo
si se cumple un cierto criterio

probemos cambiando el dato, esta vez agregando un mensaje que también confirma
si la condición no se cumple

```{r}
basura <-  6

if (basura > 900) {
  # limpiar el dato porque viene en kilos en vez de toneladas
  basura <- basura /1000
  message("valor anómalo: el valor es mayor a 900, por lo que será dividido en 1000")
} else {
  message("valor normal")
}
```

en el apartado "else" podemos especificar código que se ejecutará si la
condición es FALSE, o bien, podemos omitir el apartado "else" para que sólo
se ejecute el código si la condición es TRUE

El control de flujo resulta particularmente útil para crear funciones más complejas. Dentro de las funciones puedes crear condicionales que realizan operaciones específicas dependiendo de lo que se le entregue a la función. 

```{r}

```


También puedes crear nuevos argumentos en tu función, con los que puedes hacer que tu función trabaje de forma distinta dependiendo de lo que le especifiques.

```{r}

```





## Iteraciones 
Las alteraciones son operaciones programáticas extremadamente poderosas. Permiten generalizar tu código, en el sentido que una operación u operaciones que definas pueden aplicarse repetidas veces sobre distintos conjuntos de datos, con un alto grado de libertad en el proceso.

en una iteración, se realiza una operación multiples veces en base al vector que entregues

```{r}
pasos <- 10:20

for (i in pasos) {
  texto <- paste("este es el paso:", i)
  
  print(texto)
}
```
en este caso tenemos un vector de 10 números, por lo que el código especificado
se aplica a cada uno de los números, usando el objeto "i" como si fuera el objeto 
que contiene el valor de cada paso (10, 11, 12, etc.)


en una iteración, podemos controlar el flujo del código con if else

```{r}
for (persona in personas) {
  
  saludo <- paste("hola", persona)
  
  if (persona == "susana") {
    saludo <- paste("chao", persona)
  }
  
  print(saludo)
}
```
en este caso, ponemos una excepción para que, en un paso específico, 
el comportamiento sea distinto


en este ejemplo, controlamos el flujo del código para que hayan múltiples condiciones
y para cada condición se haga algo distinto

```{r}
for (persona in personas) {
  
  if (persona == "susana") {
    saludo <- paste("holaaaa susanaaa!")
    
  } else if (persona == "catherine") {  
    saludo <- paste("excelente pregunta, catherine")
    
  } else if (persona == "basti") {
    saludo <- sample(c("serpiente", "perro", "gato", "rata", "gallina", "pez"), 1)
    
  } else {
    saludo <- paste("hola", persona)
  }
  
  print(saludo)
}
```
por cada paso, el objeto "persona" asume el valor del elemento correspondiente del vector "personas",
y avanza por el código probando si "persona" coincide con alguna de las condiciones dadas,
y al final, si no cayó en ninguna de las comparaciones específicas, realiza una operación general para
todos los demás casos



```{r}
animo <- "feliz"
```
animo <- "enojado"
animo <- "triste"


```{r}
for (persona in personas) {
  
  if (persona == "susana") {
    
    if (animo == "feliz") {
      saludo <- paste("holaaaa susanaaa!")
      
    } else if (animo == "enojado") {
      saludo <- paste("hola po susana")
    }
    
  } else if (persona == "catherine") {  
    saludo <- paste("excelente pregunta catherine")
    
  } else if (persona == "basti") {
    saludo <- sample(animales, 1)
    
  } else {
    saludo <- paste("hola", persona)
  }
  
  print(saludo)
}
```

