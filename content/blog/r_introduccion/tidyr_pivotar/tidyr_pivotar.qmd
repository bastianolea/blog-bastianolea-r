---
title: "Transformación de datos entre formato _ancho_ y _largo_ con {tidyr}"
author: Bastián Olea Herrera
date: '2025-11-29'
format: 
  hugo-md:
    output-file: "index"
    output-ext:  "md"
weight: 9
draft: true
series: "Introducción a R"
slug: []
categories: ["Tutoriales"]
tags:
  - dplyr
  - tidyr
  - procesamiento de datos
  - datos
lang: es
execute: 
  error: true
  eval: true
  message: false
  warning: false
links:
  - icon: registered
    icon_pack: fas
    name: tidyr
    url: https://tidyr.tidyverse.org/
  - icon: github
    icon_pack: fab
    name: Código scraping
    url: https://gist.github.com/bastianolea/00d7da36e85b76de1abf9ca37014cfe4
excerpt: "Los datos pueden existir en distintos formatos o estructuras, y el poder transformar los datos entre distintas estructuras es una habilidad clave. En este tutorial aprenderemos a usar las funciones `pivot_longer()` y `pivot_wider()` del paquete `{tidyr}` para cambiar entre formatos de datos _ancho_ (_wide_) y _largo_ (_long_)."
---

Los datos pueden existir en distintos formatos o estructuras, y el poder **transformar los datos entre distintas estructuras** es una habilidad clave.

{{< imagen "featured.png" >}}

En este tutorial  aprenderemos a usar las funciones `pivot_longer()` y `pivot_wider()` del [paquete `{tidyr}`](https://tidyr.tidyverse.org/) para cambiar entre formatos de datos _ancho_ (_wide_) y _largo_ (_long_).


{{< indice >}}

## Formatos de datos
No existe una forma estandarizada de estructurar los datos. La estructura o formato que tengan los datos va a depender de muchas cosas: de dónde provienen los datos, para que se van a usar los datos, etc. Dependiendo de estas distintas necesidades los datos se pueden estructurar distintos.

Dos de estos formatos o estructuras de datos son los datos anchos y largos.

```{r}
#| echo: false
datos <- readr::read_rds("datos_latam.rds")
```

### Datos en formato ancho
El **formato ancho** (_wide_) es cuando cada variable que describe las observaciones tiene su propia columna. Esto resulta en varias columnas, cada una describiendo un aspecto distinto de cada observación.

_Por ejemplo:_

```{r}
#| echo: false
datos |> 
  dplyr::slice(1:6) |> 
  knitr::kable()
```
{{< bajada "Tabla con datos en formato ancho, con las variables distribuidas en columnas">}}

Generalmente este formato se usa para presentar los datos, ya que es fácil de leer y comparar valores lado a lado.

### Datos en formato largo
El **formato largo** (_long_) es cuando las variables se encuentran en una sola columna, y los valores de las variables en otra columna, lo que significa que cada observación puede ocupar más de una fila.

_Por ejemplo:_

```{r}
#| echo: false
datos |> 
  dplyr::slice(1:3) |> 
  tidyr::pivot_longer(cols = pobreza:escolaridad,
                      names_to = "variable", values_to = "valor") |> 
  knitr::kable()
```
{{< bajada "Tabla con datos en formato largo, con las variables distribuidas en filas">}}


Se trata de un formato de datos más conveniente para procesar información, o para organizar estructuras de datos más complejas.


## Transformación de formatos

Ahora veremos cómo podemos pasar desde una estructura o formato de datos hacia la otra. Usaremos datos sobre países de América Latina, que fueron obtenidos desde tablas de Wikipedia usando [web scraping](/blog/r_introduccion/web_scraping/). Revisa el [script del scraping aquí](https://gist.github.com/bastianolea/00d7da36e85b76de1abf9ca37014cfe4).

### Desde ancho hacia largo

Si tenemos nuestros datos cuyas variables están distribuidas en columnas, y queremos pasarlas hacia filas, necesitamos _pivotar_ la tabla hacia lo largo.

{{< imagen "pivot_ancho_largo.png" >}}

La función `pivot_longer()` toma las columnas que contienen las variables, y las _apila_ en dos nuevas columnas: una con los **nombres** de las variables, y otra con sus **valores**. 

```{r}
#| message: false
library(tidyr)
library(dplyr)
```

Veamos un ejemplo común. Cuando buscamos datos que muestran la evolución de una variable, en general los datos se estructuran con columnas que describen los valores de una variable separadas en columnas por mes o año.

```{r}
desarrollo <- tribble(
         ~pais, ~"2023", ~"2022", ~"2021", ~"2019",
       "Chile",   0.878,   0.869,   0.865,   0.867,
   "Argentina",   0.865,   0.858,   0.847,   0.861,
     "Uruguay",   0.862,   0.852,   0.837,   0.830,
      "Panamá",   0.839,   0.835,   0.819,   0.824,
  "Costa Rica",   0.833,   0.823,   0.817,   0.821,
        "Perú",   0.794,   0.790,   0.764,   0.784,
      "México",   0.789,   0.783,   0.761,   0.788,
    "Colombia",   0.788,   0.782,   0.762,   0.777,
      "Brasil",   0.786,   0.780,   0.768,   0.776,
     "Ecuador",   0.777,   0.773,   0.753,   0.765
  )
```

{{< bajada "Ejecuta este código para cargar los datos en tu sesión de R" >}}

Esta tabla contiene datos del [índice de desarrollo humano](https://es.wikipedia.org/wiki/Anexo:Países_de_América_Latina_por_índice_de_desarrollo_humano) para 10 países de la Latinoamérica:

```{r}
#| echo: false
knitr::kable(desarrollo)
```
{{< bajada "Tabla de datos en formato ancho" >}}

Tener los datos así puede ser útil para mirarlos y presentarlos, pero se vuelve difícil trabajar con ellos, por ejemplo, para calcular la variación entre cada año, o para graficar la evolución del índice de desarrollo humano a través del tiempo.

Para convertirlos en formato largo usamos `pivot_longer()` indicando las columnas que queremos _pivotar_:
```{r}
desarrollo_largo <- desarrollo |> 
  pivot_longer(cols = c("2023", "2022", "2021", "2019"),
               names_to = "año",
               values_to = "índice")
```

{{< bajada "Pivotar una tabla al formato largo" >}}

```{r}
#| echo: false
desarrollo_largo |> 
  slice(1:8) |> 
  knitr::kable()
```
{{< bajada "Datos en formato largo" >}}

Ahora cada país abarca varias filas, porque ahora las filas son también los años. Es decir, pasamos a tener una fila por cada país, tener una fila por cada año de cada país. De este modo, ahora todas las cifras se encuentran en una sola columna.

_¿Qué hicimos?_

Con `cols = c("2023", "2022", "2021", "2019")` especificamos las **columnas** que queremos _alargar_.

Con los argumentos `names_to` y `values_to` definimos el nombre de las nuevas columnas con los **nombres** y los **valores** de las columnas originales. Podemos dejar estos últimos dos argumentos vacíos para que se usen los nombres por defecto (`name` y `value`).

{{< detalles "**Ejemplos:** _¿Para qué nos sirve ésto?_" >}}

Ahora podemos filtrar por año fácilmente:
```{r}
desarrollo_largo |> 
  filter(año == "2023")
```

Podemos encontrar datos donde el índice cumpla algún criterio:

```{r}
desarrollo_largo |> 
  filter(índice > 0.86 & índice < 0.87)
```

O podemos calcular la variación entre años:
```{r}
desarrollo_largo |> 
  filter(pais == "Chile") |> 
  arrange(año) |>
  mutate(variación = índice - lag(índice),
         aumento = if_else(variación > 0, "Sí", "No"))
```

Y lo mejor es que ahora resulta mucho más fácil poder hacer el gráficos con estos datos, dado que la información necesaria se encuentra agrupada en sólo dos columnas:

```{r}
library(ggplot2)
library(thematic)

thematic_on(fg = "#553A74",
            bg = "#EAD2FA")

desarrollo_largo |> 
  filter(pais %in% c("Chile", "Argentina", "Brasil", "Perú")) |>
  ggplot() +
  aes(año, índice, color = pais, group = pais) +
  geom_line(linewidth = 1, alpha = 0.8) +
  geom_point(size = 3) +
  labs(y = "Índice de desarrollo humano", color = "País", x = NULL)
```


{{< /detalles >}}

----

Veamos otro ejemplo: una tabla con tres variables distintas, que nos muestran datos de países latinoamericanos sobre [pobreza](https://es.wikipedia.org/wiki/Anexo:Países_por_porcentaje_de_pobreza_en_Latinoamérica) y [desarrollo](https://es.wikipedia.org/wiki/Anexo:Países_de_América_Latina_por_índice_de_desarrollo_humano).

```{r}
pobreza <- tribble(
                   ~pais, ~pobreza, ~esperanza, ~escolaridad,
                 "Chile",        5,      81.17,        11.29,
               "Uruguay",        6,      78.14,        10.54,
             "Argentina",       11,      77.69,        11.18,
            "Costa Rica",       13,       80.8,         8.84,
                "Panamá",       13,      79.59,        10.83,
               "Bolivia",       15,      68.58,        10.02,
              "Paraguay",       20,      73.84,         8.93,
                "México",       22,      75.07,         9.35,
                "Brasil",       24,      75.85,         8.43,
           "El Salvador",       28,       72.1,          7.3
           )
```

{{< bajada "Ejecuta este código para cargar los datos en tu sesión de R" >}}

```{r}
#| echo: false
pobreza |> 
  knitr::kable()
```

En las **filas** tenemos las observaciones (países), y en las **columnas** tenemos tres variables distintas: pobreza (medida por el Banco Mundial como porcentaje de la población que recibe menos de US$6,85 al día), esperanza de vida, y escolaridad promedio.

Si convertimos esta tabla hacia el formato largo, vamos a tener la información estructurada de forma que cada variable ocupe una fila distinta:

```{r}
pobreza_largo <- pobreza |> 
  pivot_longer(cols = c(pobreza, esperanza, escolaridad),
               names_to = "variable",
               values_to = "valor")
```

{{< bajada "Pivotar una tabla al formato largo" >}}

```{r}
#| echo: false
pobreza_largo |> 
  head(n= 9) |> 
  knitr::kable()
```

Ahora cada país ocupa tres filas, una por cada variable. Esto nos permite filtrar y analizar los datos de forma más flexible.

{{< detalles "**Ejemplos:** _¿Para qué nos sirve ésto?_" >}}

```{r}
pobreza_largo |> 
  filter(variable == "escolaridad")
```

```{r}
library(ggplot2)
library(thematic)

thematic_on(fg = "#553A74",
            bg = "#EAD2FA")

pobreza_largo |> 
  mutate(variable = case_match(variable,
                               "pobreza" ~ "Pobreza (%)",
                               "esperanza" ~ "Esperanza de vida",
                               "escolaridad" ~ "Escolaridad promedio")) |>
  ggplot() +
  aes(y = pais, x = valor, fill = variable) +
  geom_col(width = 0.5) +
  facet_wrap(~variable, scales = "free_x") +
  guides(fill = guide_none()) +
  labs(x = NULL, y = NULL)
```

{{< /detalles >}}


#### Selección de columnas

Cuando tenemos muchas columnas para pivotar, es mejor usar técnicas o funciones que las abarquen todas en vez de escribirlas manualmente.

##### Seleccionar todas excepto algunas

Podemos usar el operador `-` para seleccionar todas las columnas excepto las que especifiquemos:

```{r}
#| eval: false
pobreza |> 
  pivot_longer(cols = -pais,
               names_to = "variable",
               values_to = "valor")
```

Esto es equivalente a escribir `cols = c(pobreza, esperanza, escolaridad)`, pero mucho más corto cuando tenemos muchas columnas.

##### Seleccionar por posición

También podemos seleccionar columnas por su posición numérica:

```{r}
#| eval: false
desarrollo |> 
  pivot_longer(cols = 2:last_col(),
               names_to = "año",
               values_to = "índice")
```

Esto selecciona desde la segunda columna hasta la última (`last_col()`); es decir, los cuatro años de la tabla). 

##### Seleccionar con funciones auxiliares

Se pueden usar todas las funciones de `{tidyselect}` para seleccionar columnas según su texto, formato, y más:

```{r}
#| eval: false
# seleccionar columnas que empiezan con cierto texto
desarrollo |> 
  pivot_longer(cols = starts_with("20"),
               names_to = "año",
               values_to = "índice")
```

```{r}
# seleccionar columnas que son numéricas
desarrollo |> 
  pivot_longer(cols = where(is.numeric),
               names_to = "año",
               values_to = "índice")
```


----

### Desde largo hacia ancho

`pivot_wider()` hace la operación inversa a `pivot_longer()`: toma valores que están apilados en filas y los distribuye en múltiples columnas nuevas. 

Es decir que pasamos de datos donde las variables de cada observación se encuentran en varias filas, a una tabla donde cada observación usará una fila y las variables estarán en **varias columnas**.

{{< imagen "pivot_largo_ancho.png" >}}

Partamos desde la tabla `pobreza_largo` que creamos anteriormente:

```{r}
#| echo: false
pobreza_largo |> 
  head(n= 9) |> 
  knitr::kable()
```
{{< bajada "Tabla con datos en formato largo" >}}

Para volver a convertirla al formato ancho usamos `pivot_wider()`:

```{r}
pobreza_ancho <- pobreza_largo |> 
  pivot_wider(names_from = variable,
              values_from = valor)
```

{{< bajada "Pivotar una tabla al formato ancho" >}}

```{r}
#| echo: false
pobreza_ancho |> 
  knitr::kable()
```

{{< bajada "Datos pivotados al formato ancho" >}}

Ahora cada variable tiene su propia columna nuevamente.

_¿Qué hicimos?_

Con `names_from` indicamos desde cuál variable sacaremos los **nombres** de las nuevas columnas que queremos crear.

Con `values_from` indicamos desde cuál columna sacaremos los **valores** que rellenarán las celdas de esas nuevas columnas.

----

Veamos otro ejemplo usando la tabla `desarrollo_largo`:

```{r}
#| echo: false
desarrollo_largo |> 
  slice(1:8) |> 
  knitr::kable()
```

{{< bajada "Tabla con datos en formato largo" >}}

Podemos convertirla de vuelta al formato ancho para tener cada año como una columna separada:

```{r}
desarrollo_ancho <- desarrollo_largo |> 
  pivot_wider(names_from = año,
              values_from = índice)
```

{{< bajada "Pivotar a formato ancho" >}}

```{r}
#| echo: false
desarrollo_ancho |> 
  knitr::kable()
```

{{< bajada "Datos pivotados a formato ancho" >}}

Ahora tenemos cada año como columna, lo que facilita comparar los valores entre años lado a lado.

{{< detalles "**Ejemplos:** _¿Para qué nos sirve ésto?_" >}}

Con los datos en formato ancho podemos calcular fácilmente diferencias entre años específicos:

```{r}
desarrollo_ancho |> 
  mutate(cambio_2019_2023 = `2023` - `2019`) |> 
  select(pais, `2019`, `2023`, cambio_2019_2023) |> 
  arrange(desc(cambio_2019_2023))
```

Pero en general el formato ancho se usa para posteriormente guardar los datos en una tabla Excel y presentárselos a otras personas, o bien, [**generar tablas** usando R](/blog/tutorial_gt/) destinadas a su lectura en informes o reportes.

{{< /detalles >}}


## ¿Cuándo usar cada formato?

No existe un formato _correcto_ qué pueda aplicarse a todas las tablas de datos. Esto debe depender de lo que necesites hacer. 

En general, te vas a dar cuenta intuitivamente que el formato de tus datos te está haciendo más difícil hacer ciertas cosas, y en ese caso se recomienda transformar la estructura, ya sea temporalmente y luego deshacer la transformación, o permanentemente en función del tipo de datos que estás trabajando.

**Formato largo:**

- Cuando vayas a [hacer gráficos con `{ggplot2}`](/blog/r_introduccion/tutorial_visualizacion_ggplot/)
- Cuando necesites agrupar y resumir datos con `group_by()` y `summarise()`
- Cuando quieras aplicar filtros sobre los valores de las variables

**Formato ancho:**

- Cuando quieras [presentar tablas](https://bastianolea.rbind.io/blog/tutorial_gt/) para [reportes](https://bastianolea.rbind.io/blog/quarto_reportes/)
- Cuando necesites comparar valores lado a lado entre variables
- Cuando vayas a exportar datos a Excel para su lectura o consulta
- Cuando quieras calcular diferencias o razones entre columnas específicas
- Cuando necesites hacer operaciones matemáticas simples entre variables


----

Saber transformar datos entre formato ancho y largo es una habilidad esencial para trabajar con datos en R. Dominar esta transformaciones de estructuras de datos te entrega mucha libertad al momento de manipular, limpiar, y trabajar con conjuntos de datos complejos.


{{< cafecito >}}

{{< cursos >}}
