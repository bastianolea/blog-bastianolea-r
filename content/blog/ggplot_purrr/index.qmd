---
title: Generar m√∫ltiples gr√°ficos autom√°ticamente con R
author: Basti√°n Olea Herrera
date: '2025-07-14'
slug: []
draft: false
format:
  hugo-md:
    output-file: "index"
    output-ext: "md"
categories: []
tags:
  - visualizaci√≥n de datos
  - automatizaci√≥n
  - purrr
  - loops
  - ggplot2
  - optimizaci√≥n
editor_options: 
  chunk_output_type: inline
execute: 
  warning: false
excerpt: "La reutilizaci√≥n de c√≥digo es s√∫per conveniente para la visualizaci√≥n de datos: una vez que dise√±aste un gr√°fico, con muy pocas modificaciones puedes adaptarlo para que funcione con una fuente de datos distintas, una fuente actualizada, o para que visualice distintas variables. En este post vamos a ver c√≥mo automatizar la creaci√≥n de gr√°ficos para que solamente tengas que dise√±ar una visualizaci√≥n que te genere m√∫ltiples resultados."

---

Uno de los principales beneficios del an√°lisis de datos en base a programaci√≥n es que **el c√≥digo es reutilizable.** Esto significa que cualquier cosa que hayas hecho puedes **reutilizarla**, y as√≠ ahorrar trabajo. El siguiente paso es reutilizar el c√≥digo de tal forma que sirva para aplicarlo a varios casos a la vez, incluso cientos o miles de veces.

La reutilizaci√≥n de c√≥digo es s√∫per conveniente para la visualizaci√≥n de datos: una vez que dise√±aste un gr√°fico, con muy pocas modificaciones puedes adaptarlo para que funcione con una fuente de datos distintas, una fuente actualizada, o para que visualice distintas variables.

En este post vamos a ver c√≥mo **automatizar la creaci√≥n de gr√°ficos** para que solamente tengas que dise√±ar una visualizaci√≥n que te genere m√∫ltiples resultados.

Lo que necesitamos para automatizar la generaci√≥n de gr√°ficos es:
1. Preparar los datos para la visualizaci√≥n
2. Dise√±ar una visualizaci√≥n que pueda adaptarse a distintos datos o variables
3. Crear un loop o iteraci√≥n donde el c√≥digo que genera el gr√°fico se ejecute m√∫ltiples veces en base a lo que necesites replicar.


## Datos

Para este tutorial usaremos [un conjunto de datos relativamente grande sobre educaci√≥n](https://github.com/bastianolea/puntajes_prueba_paes), sacado de mi [repositorio de datos sociales abiertos](https://bastianolea.github.io/datos_sociales/). Se trata de una bases de datos de resultados de puntajes de la Prueba de Acceso a la Educaci√≥n Superior (PAES).

Dado que los datos ya vienen limpios y procesados desde su fuente original [en el repositorio de GitHub](https://github.com/bastianolea/puntajes_prueba_paes), podemos cargarlos directamente desde su repositorio usando el enlace:

```{r}
#| cache: true
#| message: false
library(arrow)

# cargar datos desde GitHub
datos <- read_parquet("https://github.com/bastianolea/puntajes_prueba_paes/raw/main/datos/puntajes_paes_2024.parquet")
```

Antes que nada, miremos los datos:

```{r}
#| message: false
#| cache: true
library(dplyr)

glimpse(datos)
```

En este conjunto de datos, de 304 mil observaciones, cada fila representa a una persona que dio la _Prueba de Acceso a la Educaci√≥n Superior_ (PAES), y en las columnas se detallan caracter√≠sticas de las personas y los puntajes obtenidos. Las columnas que empiezan con `paes_` contienen los puntajes.

Exploremos visualmente dos de las variables con un [gr√°fico de dispersi√≥n](https://bastianolea.rbind.io/blog/r_introduccion/tutorial_visualizacion_ggplot/#dispersi√≥n):

```{r}
library(ggplot2)

datos |> 
  # filter(nombre_region == "Metropolitana de Santiago") |> 
  ggplot() +
  aes(paes_matematica1, paes_complectora) +
  geom_jitter(height = 10, width = 10,
              size = 0.2, alpha = 0.1) +
  theme_classic() +
  coord_fixed() +
  labs(x = "Matem√°ticas", y = "Comprensi√≥n lectora")
```

Obtenemos una tenebrosa nube que correlaciona los puntajes de la prueba de comprensi√≥n lectora y la de matem√°titas. En este gr√°fico cada punto es un estudiante, y la ubicaci√≥n del punto corresponde al puntaje que obtuvo en las pruebas de Matem√°tica y Comprensi√≥n Lectora. Como los datos vienen con m√°s variables de caracterizaci√≥n de las observaciones, podemos filtrar los datos por comuna:

```{r}
library(dplyr)

datos |> 
  filter(nombre_comuna == "La Florida")
```
Esto significa qeu podemos generar gr√°ficos para subgrupos de la poblaci√≥n; en este caso, gr√°ficos por unidades administrativas o comunas.

## Gr√°fico

{{< aviso "Si necesitas aprender a visualizar datos desde cero, [revisa este tutorial de `{ggplot2}`](https://bastianolea.rbind.io/blog/r_introduccion/tutorial_visualizacion_ggplot/)" >}}

Podemos intentar volver a generar el mismo gr√°fico con **exactamente el mismo c√≥digo**, pero antes filtrando una comuna, para obtener s√≥lo los resultados de estudiantes que viven en la comuna de La Florida:

```{r}
datos |> 
  # filtrar datos
  filter(nombre_comuna == "La Florida") |> 
  # gr√°fico
  ggplot() +
  aes(paes_matematica1, paes_complectora) +
  geom_jitter(shape = 3, 
              height = 5, width = 5,
              size = 0.4, alpha = 0.5) +
  theme_classic() +
  coord_fixed() +
  labs(subtitle = "La Florida",
       x = "Matem√°ticas", y = "Comprensi√≥n lectora")
```

Obviamente podemos filtrar por cualquier otra comuna (o cualquier otra variable) y obtendremos el gr√°fico de los estudiantes correspondientes.

Mejoremos un poco la visualizaci√≥n, ahora adem√°s con la reutilizaci√≥n en mente:

```{r}
#| warning: false
# el nombre de la comuna que seleccionamos para visualizar
comuna <- "Lo Espejo"

# filtrado de los gr√°ficos
datos <- datos |> 
  # crear variable que indica si la observacion pertenece o no a la comuna seleccionada
  mutate(seleccion = if_else(nombre_comuna == comuna, 
                             true = "Destacada", false = "Otras")) |>
  # ordenar las observaciones seg√∫n la selecci√≥n de comuna
  arrange(desc(seleccion)) |> 
  # redondear punteajes
  mutate(across(c(paes_matematica1, paes_complectora), ~signif(.x, 2)))

# gr√°fico b√°sico
grafico_base <- datos |> 
  ggplot() +
  aes(paes_matematica1, paes_complectora, 
      color = seleccion, alpha = seleccion) +
  geom_point(size = 0.4)

# modificar detalles del gr√°fico
grafico_bonito <- grafico_base + 
  # escala de colores para destacar la comuna seleccionada
  scale_color_manual(values = c("Otras" = "grey85", "Destacada" = "#6E3A98")) +
  # escala de transparencia para mejorar visualizaci√≥n
  scale_alpha_manual(values = c("Otras" = 0.1, "Destacada" = 0.3)) +
  # temas
  theme_classic() +
  theme(legend.position = "none") + # ocultar leyenda
  coord_fixed(expand = FALSE) + # gr√°fico cuadrado
  labs(subtitle = comuna, # nombre de la comuna elegida
       title = "Puntajes de prueba PAES 2024",
       x = "Matem√°ticas", y = "Comprensi√≥n lectora")

grafico_bonito
```
Efectivamente obtenemos un gr√°fico m√°s bonito ‚ò∫Ô∏è donde especificamos de antemano un objeto `comuna` con el nombre de la unidad administrativa que queremos visualizar. Luego, este objeto se usa para filtrar los datos y para poner un t√≠tulo al gr√°fico.

Tambi√©n usamos la funci√≥n `signif()` para redondear los puntajes a dos _d√≠gitos significativos_; es decir, un n√∫mero como `456` se vuelve `450`, para simplificar el ordenamiento de los puntos en el plano del gr√°fico.

## Funci√≥n

{{< aviso "Si nunca has creado una funci√≥n en R, [revisa esta gu√≠a](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#crear-funciones)" >}}

El siguiente paso es opcional, pero lo recomiendo porque simplifica bastante la lectura del c√≥digo y su mantenimiento futuro. Vamos a [**crear una funci√≥n**](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#crear-funciones) que genere el mismo gr√°fico que antes, para facilitar su reutilizaci√≥n. 

Para crear una funci√≥n, simplemente incluimos el c√≥digo dentro de `function() { }` y definimos los argumentos de la funci√≥n en `function()` y dentro de la misma. Pero como somos bacanes, en vez de `function()` vamos a usar la abreviatura `\()` üòé

```{r}
grafico <- \(datos, comuna) {
  datos |> 
    mutate(seleccion = if_else(nombre_comuna == comuna, 
                               true = "Destacada", false = "Otras")) |>
    arrange(desc(seleccion)) |> 
    mutate(across(c(paes_matematica1, paes_complectora), ~signif(.x, 2))) |> 
    ggplot() +
    aes(paes_matematica1, paes_complectora, 
        color = seleccion, alpha = seleccion) +
    geom_point(size = 0.4) +
    scale_color_manual(values = c("Otras" = "grey85", "Destacada" = "#6E3A98")) +
    scale_alpha_manual(values = c("Otras" = 0.1, "Destacada" = 0.3)) +
    theme_classic() +
    theme(legend.position = "none") +
    coord_fixed(expand = FALSE) +
    labs(subtitle = comuna, title = "Puntajes de prueba PAES 2024",
         x = "Matem√°ticas", y = "Comprensi√≥n lectora")
}
```

[Hacer una funci√≥n en R](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#crear-funciones) es como empaquetar tu c√≥digo en su propio programita para que sea m√°s f√°cil de usar sin tener que copiar y pegar todo el c√≥digo cada vez que lo necesites. Tambi√©n tiene el beneficio de que, si necesitas corregir o mejorar el c√≥digo, lo modificas una sola vez y el cambio va a aparecer en todos los dem√°s lugares que la uses. 

Ahora que creamos la funci√≥n, solo tenemos que ejecutar `grafico()` para generar el gr√°fico!

```{r}
grafico(datos, "La Reina")

grafico(datos, "Cerrillos")
```

## Automatizaci√≥n

Una vez que hayamos desarrollado el c√≥digo que genera la visualizaci√≥n, y que hayamos probado y confirmado que el c√≥digo va a servir en distintas situaciones (en nuestro caso, filtrando distintas comunas), podemos [introducir el c√≥digo a un _loop_](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#bucles) para **generar todas las variaciones que queramos** del mismo gr√°fico.

En el caso de nuestro conjunto de datos, esto ser√≠a **hacer un gr√°fico por cada comuna** en la base de datos. Si hici√©ramos esto a mano, tendr√≠amos que copiar y pegar m√°s de 300 veces el mismo c√≥digo üò∞ As√≠ que, para no tener que hacer las cosas a mano como los perdedores, vamos a **automatizar el proceso de generaci√≥n de gr√°ficos**. 

Definamos primero la lista de elementos por los que queremos crear los gr√°ficos. Esto pueden ser a√±os, pa√≠ses, nombres, o en nuestro caso, divisiones administrativas como pueden ser comunas.

```{r}
comunas <- unique(datos$nombre_comuna)
```

El vector anterior nos da todas las categor√≠as de la variable `nombre_comuna` del dataset `datos`, eliminando duplicados con `unique()`. Estos ser√°n los valores por los que iremos iterando: por cada uno de estos valores vamos a querer que se produzca un gr√°fico distinto.

En otras palabras, queremos aplicar nuestra funci√≥n `grafico()` (o el c√≥digo para generar el gr√°fico) una vez por cada comuna en el dataset. Para esto utilizaremos un [bucle o _loop_ en R](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#bucles) nos permite **repetir un conjunto de instrucciones varias veces**.

{{< aviso "Si nunca has hecho un loop en R, [revisa esta gu√≠a](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#bucles" >}}

Si bien en R podemos crear loops o bucles con `for`, usaremos `map()` del [paquete `{purrr}`](https://purrr.tidyverse.org) para lograr lo mismo de una forma m√°s elegante y eficiente.

Dentro de `map()`, primero entregamos los **elementos por los que queremos iterar** (en nuestro caso, los nombres de las comunas), y **luego se aplica una funci√≥n**[^1], dentro de la cual ponemos lo que queremos que pase en cada paso de la iteraci√≥n. O sea que, por cada elemento de `comunas`, se va a aplicar el c√≥digo del gr√°fico.

Dentro de la funci√≥n, simplemente ponemos el c√≥digo que genera el gr√°fico, y luego le pedimos que guarde el resultado en nuestro computador. Es muy importante que los nombres de archivo sean distintos! De lo contrario los resultados se van a ir sobrescribiendo unos a otros üôÑ As√≠ que usamos el nombre de la comuna dentro de `paste()` para crear nombres de archivo √∫nicos.

[^1]: En vez de una funci√≥n, usaremos una [funci√≥n an√≥nima](https://www.jumpingrivers.com/blog/new-features-r410-pipe-anonymous-functions/), lo que significa que crearemos la funci√≥n dentro de `map()` solamente porque es m√°s r√°pido.

```{r}
library(purrr)

map(comunas[1:10], # elementos por los que se va a iterar
    \(comuna) { # cada elemento va a pasar a la funci√≥n como un objeto llamado `comuna`
      
      # crear gr√°ficos
      grafico <- grafico(datos, comuna)
      
      # guardar gr√°ficos
      ggsave(plot = grafico, 
             filename = paste0("graficos/Gr√°fico Paes ", comuna, ".jpeg"), # nombre del archivo
             width = 6, height = 6)
    })
```

Con tan s√≥lo ejecutar el c√≥digo anterior, obtendremos m√°s de 300 gr√°ficos! Pero como son tantos, le puse `comunas[1:10]` para que s√≥lo se hagan las primeras 10 üòÖ

{{< imagen "graficos.jpg" >}}

## Optimizaci√≥n

Naturalmente, generar cientos de gr√°ficos puede demorar unos minutos, sobre todo si los datos son muy grandes (y en nuestro caso, cada gr√°fico tiene m√°s de 300 mil puntos‚Ä¶). 

Lo bueno es que podemos aprovechar todo el potencial de nuestras computadoras [modificando el c√≥digo para que el proceso sea multiprocesador](https://bastianolea.rbind.io/blog/furrr_multiprocesador/); es decir, que se usen todos los procesadores de nuestro computador al mismo tiempo. Tan s√≥lo especificamos cu√°ntos procesadores queremos usar con `plan(multisession, workers = 6)`, y luego reemplazamos `map()` por `future_map()` de [`{furrr}`](https://furrr.futureverse.org):

```{r}
#| eval: false
library(furrr)
plan(multisession, workers = 6)

future_map(comunas[1:20],
           \(comuna) {
             
             grafico <- grafico(datos, comuna)
             
             ggsave(plot = grafico, 
                    filename = paste0("graficos/Gr√°fico Paes ", comuna, ".jpeg"), # nombre del archivo
                    width = 6, height = 6)
           })
```

```{=html}
<div style="max-width: 280px; margin:auto;">
  <img src="r_multicore.png" style="border-radius: 7px; width: 80%; max-width: 700px; display: block; margin: auto; margin-bottom: 8px; margin-top: 8px;">
  </div>
```

{{< bajada "Visualizaci√≥n de uso de CPU al procesar gr√°ficos multicore con R, demostrando que se usan todos los procesadores al mismo tiempo" >}}



Listo! üéâ Imag√≠nate todo el tiempo que ahorramos: podemos obtener cientos de gr√°ficos con tan s√≥lo presionar el bot√≥n _Run_ (o la combinaci√≥n _control_ + _enter_), y si tenemos que actualizar, modificar o mejorar los gr√°ficos, simplemente cambiamos el c√≥digo en la funci√≥n y volvemos a ejecutar el _loop_. Excelente! Esto hace que aprender a programar valga la pena, cierto?‚Ä¶ cierto? ü•∫

----

{{< cafecito >}}

{{< cursos >}}