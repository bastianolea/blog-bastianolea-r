---
title: 'C贸mo dejar de repetirte y escribir c贸digo m谩s eficiente en R'
subtitle: 'Este script enorme podr铆a haber sido un `for` loop'
author: Basti谩n Olea Herrera
date: '2026-02-18'
slug: []
draft: false
categories: []
tags:
  - loops
  - optimizaci贸n
  - consejos
format:
  hugo-md:
    output-file: index
    output-ext: md
editor_options: 
  chunk_output_type: console
links:
  - icon: file-code
    icon_pack: fas
    name: C贸digo
    url: https://gist.github.com/bastianolea/a80092f4552e9d4e648eca7fd287baeb
excerpt: "Cuando trabajas con c贸digo, lo mejor es que lo organices para que sea m谩s f谩cil de entender y m谩s f谩cil de mantener. Esto, a su vez, reducir谩 tu carga mental, te volver谩 m谩s eficiente, y tu _yo_ del futuro te lo agradecer谩. En este tutorial te doy algunos consejos para lograrlo usando scripts separados, creando funciones, y haciendo _loops_ para evitar la repetici贸n y mejorar la legibilidad de tu c贸digo."
---


El otro d铆a me lleg贸 un script (muy probablemente hecho por una IA) de m谩s de 9.000 l铆neas! 

{{< video "script.mov" >}}

Igual era entendible, porque era un script que produc铆a cientos de gr谩ficos. Pero revisando el script me doy cuenta de que tambi茅n **se repiten cientos de veces los mismos patrones de c贸digo.** 

Scripts como 茅stos suelen ser apenas una docena de bloques de c贸digo distintos, pero repetidos muchas veces cada uno con m铆nimas diferencias entre ellos: referencias a columnas distintas, etc.

Esa extensi贸n y ese nivel de repetici贸n hizo que modificar el script para mejorar los gr谩ficos, que en teor铆a eran un pu帽ado de visualizaciones repetidas muchas veces, fuera un enorme dolor de cabeza.

Al tiro pens茅: _Este script enorme podr铆a haber sido un `for` loop_ 

_**驴Qu茅 tiene de malo la repetici贸n?**_
- Produce scripts **dif铆ciles de revisar y entender**, porque son tan eternos que no puedes contenerlos en tu cabeza 
- Es c贸digo **dif铆cil de mantener**, porque si quieres hacer un cambio, vas a tener que aplicarlo infinitas veces de forma manual 
- Producen **problemas a largo plazo**, porque puede ser que aparezca un error en el c贸digo y vas a tener que bucear  entre miles de l铆neas para encontrarlo

Aqu铆 dejo algunos consejos para escribir c贸digo m谩s **eficiente**, m谩s **f谩cil de entender**, y **m谩s f谩cil de mantener**.

----

## Separar un script en partes

Si tienes un script muy largo, lo primero que puedes hacer es **separar el script en varias partes**, y cada parte ponerla en un archivo distinto. 

Si un script requiere que se ejecute otro, puedes agregar `source()` para que dentro de un script se ejecute otro script.

Por ejemplo, en un script pones todo el c贸digo de la carga de datos, en otro pones las funciones que usar谩s, y el tercer script lo empiezas con `source("cargar.R")` y `source("funciones.R")`.

{{< columnas >}}

Entonces pasas desde esto:
- `script_enorme.R`


{{< columna >}}

A esto:
- `cargar.R`
- `funciones.R`
- `pruebas.R`
- `gr谩ficos.R`

{{< fin_columnas >}}

Entonces, si necesitas cambiar algo en la carga de datos, vas al script correspondiente y lo arreglas!

Otra opci贸n es tener todo en scripts separados, y luego tener un **script principal que ejecute todos los pasos necesarios** con `source()`, una especie de orquestador de todos los pasos de tu proyecto. En estos casos se recomienda anteceder los scripts con una numeraci贸n para registrar el orden de los pasos.

{{< info "Para orquestar _pipelines_ en R existe [el paquete `{targets}`](https://docs.ropensci.org/targets/), que permite declarar flujos o _pipelines_ con los pasos necesarios para tu proyecto, coordinando la ejecuci贸n de todos los pasos. Tiene el beneficio de que optimiza el tiempo de procesamiento al ejecutar solamente los pasos que tienen cambios. Para m谩s informaci贸n [revisa este libro.](https://books.ropensci.org/targets/)">}}

## Crear funciones

Si tienes un **bloque de c贸digo que se repite muchas veces**, lo mejor es convertirlo en una funci贸n, y luego llamar a esa funci贸n cada vez que necesites ejecutar ese bloque de c贸digo.

_**Por qu茅 usar funciones?**_
- Permiten **ordenar el c贸digo**, porque _esconden_ la complejidad del c贸digo dentro de la funci贸n, dejando s贸lo lo necesario a la vista: pasas de muchas l铆neas de c贸digo a una funci贸n con un nombre que describa lo que hace
- Permiten **reutilizar c贸digo**, porque una vez que creas la funci贸n, puedes usarla las veces que quieras sin tener que copiar y pegar el mismo bloque de c贸digo
- Te ayudan a **mantener el c贸digo**, porque si despu茅s necesitas hacer un cambio o correcci贸n, la haces en un s贸lo lugar, y ese cambio se va a aplicar a todas las veces que uses la funci贸n

{{< info "Para aprender lo b谩sico sobre **crear funciones** en R, [revisa este tutorial](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#crear-funciones)" >}}


Pong谩monos en el caso de que vamos a procesar los [resultados del Censo de poblaci贸n y vivienda 2024](https://censo2024.ine.gob.cl/resultados/) de Chile, y cargamos los **datos sobre poblaci贸n seg煤n g茅nero**:

{{< boton "Descargar datos" "P5_Genero.xlsx" "fas fa-file-download" >}}

```{r}
#| message: false
#| warning: false
library(readxl)
library(dplyr)
library(janitor)
library(tidyr)

# cargar datos
genero <- read_xlsx("P5_Genero.xlsx", sheet = 2)

# limpiar y procesar
genero_long <- genero |> 
  row_to_names(3) |> 
  pivot_longer(cols = 4:last_col(),
               names_to = "genero",
               values_to = "poblacion") |> 
  select(region = 2, genero, poblacion) |> 
  mutate(poblacion = as.numeric(poblacion)) |> 
  mutate(tipo = case_when(genero %in% c("Masculino", "Femenino") ~ "Binario cis",
                          genero %in% c("No binario", "Transfemenino", "Transmasculino") ~ "Trans",
                          TRUE ~ "Otros")) |> 
  filter(tipo != "Otros")

genero_long
```


Ahora que tenemos los datos por regi贸n y g茅nero, procedemos a **visualizar los datos**:

```{r}
library(ggplot2)

# visualizar
genero_long |> 
  filter(region == "Pa铆s") |> 
  ggplot(aes(x = genero, y = poblacion, fill = genero)) +
  geom_col(width = 0.5, color = "#EAD2FA") +
  geom_text(aes(label = scales::comma(poblacion)), 
            position = position_dodge(width = 0.9), 
            vjust = -0.5, 
            size = 3) +
  scale_fill_brewer(type = "qual", palette = "Set2") +
  scale_y_continuous(labels = scales::comma,
                     expand = expansion(mult = c(0, 0.1))) +
  scale_x_discrete(labels = label_wrap_gen(15)) +
  facet_wrap(~tipo, scales = "free") +
  guides(fill = guide_none()) +
  theme_grey(ink = "#553A74",
             paper = "#EAD2FA",
             accent = "#9069C0") +
  labs(title = "Poblaci贸n nacional seg煤n g茅nero",
       subtitle = "Censo 2024",
       x = "G茅neros", y = "Poblaci贸n (a distintas escalas)")
```


Pero imaginemos que ahora queremos **hacer el mismo gr谩fico varias veces**. 驴Copiamos el bloque del gr谩fico y lo pegamos las veces que lo necesitemos? **NO!** 

En vez de repetir el c贸digo, copiamos el c贸digo y creamos funciones para ordenarlo y hacerlo m谩s manejable:


```{r}
# funci贸n para cargar datos
censo_cargar_genero <- function(archivo = "P5_Genero.xlsx") {
  read_xlsx(archivo, sheet = 2)
}
```

```{r}
# funci贸n para procesar datos
censo_procesar_genero <- function(genero) {
  
  genero |> 
    row_to_names(3) |> 
    pivot_longer(cols = 4:last_col(),
                 names_to = "genero",
                 values_to = "poblacion") |> 
    select(region = 2, genero, poblacion) |> 
    mutate(poblacion = as.numeric(poblacion)) |> 
    mutate(tipo = case_when(genero %in% c("Masculino", "Femenino") ~ "Binario cis",
                            genero %in% c("No binario", "Transfemenino", "Transmasculino") ~ "Trans",
                            TRUE ~ "Otros")) |> 
    filter(tipo != "Otros") |> 
    filter(!is.na(region))
}
```

```{r}
# funci贸n para visualizar datos 
censo_grafico_genero <- function(genero_long,
                                 filtro = "Pa铆s",
                                 titulo = "Poblaci贸n nacional seg煤n g茅nero") {
  genero_long |> 
    filter(region == filtro) |> 
    ggplot(aes(x = genero, y = poblacion, fill = genero)) +
    geom_col(width = 0.5, color = "#EAD2FA") +
    geom_text(aes(label = scales::comma(poblacion)), 
              position = position_dodge(width = 0.9), 
              vjust = -0.5, 
              size = 3) +
    scale_fill_brewer(type = "qual", palette = "Set2") +
    scale_y_continuous(labels = scales::comma,
                       expand = expansion(mult = c(0, 0.1))) +
    scale_x_discrete(labels = label_wrap_gen(15)) +
    facet_wrap(~tipo, scales = "free") +
    guides(fill = guide_none()) +
    theme_grey(ink = "#553A74",
               paper = "#EAD2FA",
               accent = "#9069C0") +
    labs(title = titulo,
         subtitle = "Censo 2024",
         x = "G茅neros", y = "Poblaci贸n (a distintas escalas)")
}
```

Lo que hicimos fue simplemente **meter las partes del c贸digo dentro de `function()`** para crear funciones.

Ahora cuando necesitemos ejecutar esas partes del c贸digo, simplemente llamamos las funciones:

```{r}
#| message: false
#| warning: false
genero <- censo_cargar_genero()

genero_long <- censo_procesar_genero(genero)

censo_grafico_genero(genero_long,
                     filtro = "Valpara铆so",
                     titulo = "Poblaci贸n de Valpara铆so seg煤n g茅nero")
```

隆Mucho m谩s breve y ordenado! 

Ahora podemos **reutilizar la funci贸n** para generar otro gr谩fico similar en tan s贸lo un par de l铆neas:

```{r}
censo_grafico_genero(genero_long,
                     filtro = "Biob铆o",
                     titulo = "Poblaci贸n de Biob铆o seg煤n g茅nero")
```

En el fondo lo que hicimos fue _esconder_ parte del c贸digo dentro de las funciones, despejando nuestro script.

Ahora, si queremos **hacer alg煤n cambio en el c贸digo**, cambiamos la funci贸n que creamos y re-ejecutamos la funci贸n, y as铆 el cambio se aplicar谩 a las siguientes veces que ocupemos la funci贸n. 
Por ejemplo, cambiemos la paleta de colores:

{{< detalles "Ver c贸digo de la funci贸n con cambios" >}}

```{r}
# cambiamos la funci贸n, agregando el c贸digo nuevo dentro de ella
censo_grafico_genero <- function(genero_long,
                                 filtro = "Pa铆s",
                                 titulo = "Poblaci贸n nacional seg煤n g茅nero") {
  genero_long |> 
    filter(region == filtro) |> 
    ggplot(aes(x = genero, y = poblacion, fill = genero)) +
    geom_col(width = 0.5, color = "#EAD2FA") +
    geom_text(aes(label = scales::comma(poblacion)), 
              position = position_dodge(width = 0.9), 
              vjust = -0.5, 
              size = 3) +
    # scale_fill_brewer(type = "qual", palette = "Set2") +
    #### cambio en la funci贸n para cambiar paleta de colores
    scale_fill_manual(values = c("Femenino" = "#9069C0", 
                                 "Masculino" = "#6974C0", 
                                 "No binario" = "#C46EBA", 
                                 "Transfemenino" = "#9069C0", 
                                 "Transmasculino" = "#6974C0")) +
    ####
    scale_y_continuous(labels = scales::comma,
                       expand = expansion(mult = c(0, 0.1))) +
    scale_x_discrete(labels = label_wrap_gen(15)) +
    facet_wrap(~tipo, scales = "free") +
    guides(fill = guide_none()) +
    theme_grey(ink = "#553A74",
               paper = "#EAD2FA",
               accent = "#9069C0") +
    #### cambio en la funci贸n para usar el filtro en el t铆tulo
    labs(title = paste("Poblaci贸n de", filtro, "seg煤n g茅nero"),
         ####
         subtitle = "Censo 2024",
         x = "G茅neros", y = "Poblaci贸n (a distintas escalas)")
}
```

{{< /detalles >}}

Ahora que actualizamos la funci贸n, al volver a usarla tendr谩 los cambios nuevos:

```{r}
censo_grafico_genero(genero_long,
                     filtro = "Arica y Parinacota")
```


## Hacer un _loop_ o bucle

Otro caso de repetici贸n es cuando tenemos que **hacer una misma cosa muchas veces**.

Siguiendo el ejeplo anterior, donde creamos una funci贸n, una opci贸n es usar la funci贸n muchas veces:

```r
censo_grafico_genero(genero_long, filtro = "Arica y Parinacota")

censo_grafico_genero(genero_long, filtro = "Tarapac谩")

censo_grafico_genero(genero_long, filtro = "Antofagasta")

censo_grafico_genero(genero_long, filtro = "Coquimbo")
```

... y as铆 hasta el infinito. Pero esto no es eficiente!

Lo mejor ser铆a usar un _loop_ o bucle, que es una estructura de c贸digo que permite repetir un bloque de c贸digo varias veces, cambiando alguna parte del c贸digo cada vez.

{{< info "Para aprender lo b谩sico sobre **crear _loops_** en R, [revisa este tutorial](https://bastianolea.rbind.io/blog/r_introduccion/r_intermedio/#bucles)" >}}

En este caso, el c贸digo repetido siempre es la misma funci贸n (o el bloque de c贸digo que genera el gr谩fico), y lo 煤nico que cambia son los argumentos que se le enrega a la funci贸n (la regi贸n a filtrar), as铆 que podemos hacer un _loop_ que ejecute varias veces el c贸digo, y en cada paso cambie el filtro:

```{r}
# obtener vector con las regiones
regiones <- unique(genero_long$region)
```

Primero obtenemos un vector que contenga el valor que queremos que se use en cada paso del _loop_, y luego construimos el _loop_ para que, por cada valor del vector (`for (region in regiones)`), ejecute el bloque de c贸digo que queremos repetir:

```r
# hacer un loop para generar un gr谩fico por cada regi贸n
for (region in regiones) {
  censo_grafico_genero(genero_long, filtro = region)
}
```

Con s贸lo esas pocas l铆neas, generamos gr谩ficos para todas las regiones del pa铆s!

{{< imagen "collage.png" >}}


## Conclusi贸n

En resumidas cuentas, si aplicamos lo aprendido en este tutorial, lo que hicimos quedar铆a as铆:

```r
source("funciones.R")

# cargar
genero <- censo_cargar_genero()

# procesar
genero_long <- censo_procesar_genero(genero)

# loop
for (region in unique(genero$regiones)) {
  censo_grafico_genero(genero_long, filtro = region)
}
```

Hermoso. Elegante. Conciso. Reproducible. Una obra de arte 

Quiz谩s lo mejor que puedes hacer con tu c贸digo es **hacerlo legible** y **no repetirte**. Como hemos visto, lo mejor es **separar el c贸digo en partes**, **crear funciones** para ordenar el c贸digo y hacerlo m谩s manejable, y **usar loops** para ejecutar un mismo c贸digo varias veces.

{{< cafecito >}}

{{< cursos >}}