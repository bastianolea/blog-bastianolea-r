---
title: Unir o cruzar datos con left_join()
author: Basti√°n Olea Herrera
date: '2025-08-16'
draft: false
format:
  hugo-md:
    output-file: "index"
    output-ext: "md"
slug: []
categories:
  - tutoriales
tags:
  - procesamiento de datos
  - limpieza de datos
editor_options: 
  chunk_output_type: console
excerpt: Un _left join_ realiza una uni√≥n o combinaci√≥n entre dos tablas de datos a partir de una variable en com√∫n o _clave_ (_key_). En otras palabras, un _left join_ toma dos tablas que tienen datos distintos, pero que comparten una variable o columna en com√∫n, y usa esta variable en com√∫n para unir las observaciones de ambas tablas. En este tutorial explico a hacer _left joins_ con frutas, animales, y uso irregular de licencias m√©dicas.
---

El _left join_ es una de las operaciones b√°sicas del trabajo con datos, en el sentido de que realiza una operaci√≥n sencilla que a la vez es muy √∫til. Sirve tanto para limpiar datos como para procesarlos y obtener nuevas relaciones entre ellos.

Un _left join_ realiza una uni√≥n o combinaci√≥n entre dos tablas de datos a partir de una variable en com√∫n o _clave_ (_key_). En otras palabras, un _left join_ toma dos tablas que tienen datos distintos, pero que comparten una variable o columna en com√∫n, y usa esta variable en com√∫n para **unir las observaciones de ambas tablas**.

{{< imagen "left_join_a.png" >}}

{{< bajada "Esquema de una uni√≥n entre tablas con _left join_" >}}

En el ejemplo anterior, tenemos dos tablas, ambas con tres variables distintas, pero en ambas tablas tenemos una variable que contiene informaci√≥n equivalente. En la vida real, esto podr√≠an ser nombres de personas, nombres de pa√≠ses, identificadores √∫nicos de personas o instituciones, fechas, etc√©tera. Esta variable compartida entre las tablas es la **llave** que usaremos para la uni√≥n.

Al realiazr la uni√≥n con _left join_ obtenemos una nueva tabla que combina las observaciones de ambas, uniendo las filas de la primera tabla (_x_) con las filas de al segunda tabla (_y_) que se correspondan seg√∫n la llave en com√∫n.

{{< imagen "left_join_b.png" >}}

{{< bajada "Esquema del resultado del _left join_" >}}

## Ejemplo de una uni√≥n de tablas en R

Para unir dos tablas en R, usamos la funci√≥n `left_join()` de `{dplyr}`.

```{r}
#| message: false
library(dplyr)
```

Primero creemos una tabla de base con datos de ejemplo.

```{r}
frutas_x <- tibble(fruta = c("pera", "manzana", "uva"),
                   color = c("verde", "roja", "morada"))
```

```{r}
#| echo: false
knitr::kable(frutas_x, format = "markdown", align = "c")
```

En esa tabla tenemos tres observaciones que corresponden a animales, descritos en la primera columna, y una segunda columna con caracter√≠sticas de los mismos.

Ahora creemos una segunda tabla, que adem√°s de tener la misma columna que describe las frutas, agrega una nueva variable sobre las frutitas üçêüçéüçá

```{r}
frutas_y <- tibble(fruta = c("pera", "manzana", "uva"),
                   sabor = c("deliciosa", "buena", "ricolina"))
```

```{r}
#| echo: false
knitr::kable(frutas_y, format = "markdown", align = "c")
```

Dado que ambas tablas comparten la variable `fruta`, si hacemos un _left join_ ambas tablas se cruzar√°n en base a esta variable, resultando en una tabla nueva:

```{r}
frutas_2 <- left_join(frutas_x, frutas_y)
```

```{r}
#| echo: false
knitr::kable(frutas_2, format = "markdown", align = "c")
```

El resultado de la uni√≥n es una nueva tabla que tiene las tres variables √∫nicas obtenidas del cruce de las dos tablas distintas. En este caso, el _left join_ nos permite agregar informaci√≥n sobre una misma unidad de observaci√≥n proveniente de distintas fuentes.


## Otro ejemplo

Veamos un segundo ejemplo con m√°s filas y m√°s columnas, √©sta vez sobre animalitos üêàüêÄüêï

```{r}
animales_x <- tibble(animal = c("gato", "rat√≥n", "perro", "pez"),
                     color = c("gris", "negro", "blanco", "azul"),
                     tama√±o = c(34, 16, 50, 3))
```

```{r}
#| echo: false
knitr::kable(animales_x, format = "markdown", align = "c")
```

La primera tabla contiene los nombres de animales (identificador √∫nico), sus colores y sus medidas. La segunda tabla tambi√©n contiene nombres, pero agrega su cantidad de patas[^1] y sus edades.

[^1]: el gatito lamentablemente sufri√≥ un accidente y perdi√≥ una patita trasera üòø

```{r}
animales_y <- tibble(animal = c("perro", "gato", "pez"),
                     patas = c(4, 3, 0),
                     edad = c(8, 3, 1))
```

```{r}
#| echo: false
knitr::kable(animales_y, format = "markdown", align = "c")
```

Las dos tablas tienen distinta cantidad de observaciones, y adem√°s las observaciones clave (columna `animal`) que se usar√°n como llave de uni√≥n est√°n desordenadas.

Cuando los data frames tienen distinta cantidad de filas, el _orden_ en que hacemos la uni√≥n es importante: en un _**left** join_ la primera tabla (o izquierda) es la tabla principal, a la cual se le agregan las columnas de una segunda tabla, en base a las coincidencias de la columna clave. Por lo tanto, si unimos o cruzamos las tablas poniendo primero la tabla m√°s grande y despu√©s la m√°s peque√±a, obtendremos casos perdidos por las filas de la primera tabla que no obtuvieron coincidencias en la segunda.

```{r}
animales_3 <- left_join(animales_x, animales_y)
```

```{r}
#| echo: false
knitr::kable(animales_3, format = "markdown", align = "c")
```

Como podemos ver, obtenemos celdas con `NA` en la observaci√≥n _rat√≥n_, debido a que en la segunda tabla (`animales_y`) no hab√≠an datos sobre este animalito. Una pena üòî

Tambi√©n ser√≠a una opci√≥n hacer el cruce al rev√©s, poniendo primero la tabla `animales_y` (3 filas) y despu√©s `animales_x` (4 filas), con el objetivo de que las observaciones de la tabla `animales_x` complementen las observaciones de `animales_y` donde hayan coincidencias, y descartando los casos que no tienen en com√∫n:

```{r}
animales_3 <- left_join(animales_y, animales_x)
```

```{r}
#| echo: false
knitr::kable(animales_3, format = "markdown", align = "c")
```

Ahora no tenemos datos perdidos, porque si bien `animales_x` ten√≠a m√°s observaciones que `animales_y`, `animales_y` conten√≠a todas las observaciones de `animales_x` identificadas por la variable `animal`, lo que podemos confirmar [comparando las diferencias entre ambas columnas con la funci√≥n `waldo::compare()`](/blog/diferencias):

```{r}
library(waldo)

compare(sort(animales_x$animal), 
        sort(animales_y$animal))
```

## Caso licencias falsas

Un caso ic√≥nico de uso de _left join_ fue el [estudio realizado por la Contralor√≠a General de la Rep√∫blica de Chile](https://www.biobiochile.cl/noticias/nacional/chile/2025/05/20/contraloria-detecta-que-25-mil-funcionarios-publicos-salieron-del-pais-mientras-estaban-con-licencia.shtml), donde se cruzaron bases de datos que ten√≠an en com√∫n la posibilidad de identificar funcionarios p√∫blicos:

> Se trata de un estudio a partir del cruce de informaci√≥n de las salidas del pa√≠s registradas por la Polic√≠a de Investigaciones (PDI), la base de funcionarios p√∫blicos y las licencias m√©dicas que se otorgaron entre el 2023 y 2024. (Fuente: [B√≠o B√≠o](https://www.biobiochile.cl/noticias/nacional/chile/2025/05/20/contraloria-detecta-que-25-mil-funcionarios-publicos-salieron-del-pais-mientras-estaban-con-licencia.shtml))

La hip√≥tesis ser√≠a que una persona que sale del pa√≠s durante su licencia m√©dica ser√≠a probablemente una persona que consigui√≥ una licencia falsa para tomarse vacaciones üèñÔ∏è‚òÄÔ∏è

Simulemos lo que podr√≠a haber hecho la Contralor√≠a para detectar estos casos. Asumimos que contaron con (al menos) tres bases de datos: una de funcionarios p√∫blicos, una de licencias m√©dicas, y otra de viajes al extranjero, las tres teniendo en com√∫n el RUN (c√≥digo de identificaci√≥n √∫nico de ciudadanos chilenos) para poder cruzar las personas.

```{r}
options(scipen = 9999)

funcionarios <- tibble(run = c(10000001, 10000002, 10000003),
                       nombre = c("mar√≠a", "pepito", "juanito"),
                       ministerio = c("defensa", "econom√≠a", "hacienda"))
```


```{r}
#| echo: false
knitr::kable(funcionarios, format = "markdown", align = "c", scientific = F)
```

Tenemos identificados tres funcionarios p√∫blicos de distintos servicios. 

Luego tenemos una base de datos con licencias m√©dicas de trabajadores que pueden o no ser funcionarios p√∫blicos. Con la base de los RUN de funcionarios p√∫blicos podemos identificar si las licencias corresponden a funcionarios p√∫blicos y no a trabajadores del sector privado.


```{r}
licencias <- tibble(run = c(10000001, 10000002, 10000003, 10000004),
                    licencia = c(FALSE, FALSE, TRUE, TRUE),
                    licencia_inicio = c(NA, "2024-04-10", "2024-02-04", "2010-09-18"),
                    licencia_fin = c(NA, "2024-04-13", "2024-02-18", "2030-12-31"))
```

```{r}
#| echo: false
knitr::kable(licencias, format = "markdown", align = "c")
```

Lo importante de esta tabla es que tenemos una fecha de inicio y una fecha de fin de la licencia m√©dica.

Finalmente tenemos la informaci√≥n de salidas del pa√≠s de distintas personas, que pueden o no ser funcionarios p√∫blicos, y que pueden o no haber estado con licencia m√©dica ü§î

```{r}
viajes <- tibble(run = c(10000005, 10000001, 10000002, 10000003, 10000008),
                 viaje_destino = c("Bolivia", "Per√∫", "Argentina", "Italia", "Espa√±a"),
                 viaje_fecha = c("2021-01-06", "2021-02-15", "2023-06-23", "2024-02-09", "2025-08-17")
)
```

```{r}
#| echo: false
knitr::kable(viajes, format = "markdown", align = "c")
```

Ahora que tenemos datos simulados, usaremos `{dplyr}` para trabajar con los datos y encontrar respuestas.

{{< aviso "Si necesitas aprender lo b√°sico del manejo de datos con R, revisa este [tutorial b√°sico de `{dplyr}`!](/blog/r_introduccion/dplyr_intro/)" >}}

Lo primero ser√≠a **filtrar las licencias m√©dicas** para que solamente correspondan con funcionarios p√∫blicos (tambi√©n podr√≠a hacerse con `left_join()` pero creo que es m√°s pertinente un filtro)

```{r}
licencias_f <- licencias |> 
  # s√≥lo funcionarios p√∫blicos
  filter(run %in% funcionarios$run)
```

Luego, **cruzamos los datos** de licencias de funcionarios p√∫blicos con el registro de salidas del pa√≠s:
```{r}
# cruzar con viajes
cruce <- licencias_f |> 
  left_join(viajes, join_by(run))
```

Finalmente revisamos si los viajes fueron durante el tiempo de licencia m√©dica, y si los viajes fueron fuera del pa√≠s. Podemos hacer esto con un filtro, o preferentemente creando una columna nueva (`irregular`) que indique si se cumple o no la evaluaci√≥n.

```{r}
# revisar si viajaron fuera del pa√≠s durante licencia
resultado <- cruce |>
  # crear una nueva variable
  mutate(irregular = 
           licencia == TRUE & # personas on licencia
           viaje_destino != "Chile" & # viajes fuera de Chile
           between(viaje_fecha, 
                   licencia_inicio, licencia_fin) # viaje durante el tiempo de licencia
  ) |> 
  select(-viaje_destino)
```

```{r}
#| echo: false
knitr::kable(resultado, format = "markdown", align = "c")
```

‚ö†Ô∏è Detectamos un caso de funcionario p√∫blico que viaj√≥ fuera del pa√≠s durante su licencia m√©dica! La √∫ltima columna marca `TRUE` si se trata de un caso irregular.


## Conclusi√≥n

Podemos usar `left_join()` para **completar los datos** sobre nuestra unidad de an√°lisis si la informaci√≥n viene diseminada en distintas tablas o archivos. Pero tambi√©n podemos utilizarla para **complementar datos** desde distintas fuentes, aumentando la informaci√≥n que tenemos sobre las observaciones que estemos estudiando, o bien, para realizar **cruces de informaci√≥n** que nos entreguen coincidencias relevantes. 

{{< cafecito >}}

{{< cursos >}}