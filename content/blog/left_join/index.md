---
title: Unir o cruzar datos con left_join()
author: Basti√°n Olea Herrera
date: '2025-08-16'
draft: false
format:
  hugo-md:
    output-file: index
    output-ext: md
slug: []
categories: []
tags:
  - procesamiento de datos
  - limpieza de datos
editor_options:
  chunk_output_type: console
excerpt: >-
  Un _left join_ realiza una uni√≥n o combinaci√≥n entre dos tablas de datos a
  partir de una variable en com√∫n o _clave_ (_key_). En otras palabras, un _left
  join_ toma dos tablas que tienen datos distintos, pero que comparten una
  variable o columna en com√∫n, y usa esta variable en com√∫n para unir las
  observaciones de ambas tablas. En este tutorial explico a hacer _left joins_
  con frutas, animales, y uso irregular de licencias m√©dicas.
---


El *left join* es una de las operaciones b√°sicas del trabajo con datos, en el sentido de que realiza una operaci√≥n sencilla que a la vez es muy √∫til. Sirve tanto para limpiar datos como para procesarlos y obtener nuevas relaciones entre ellos.

Un *left join* realiza una uni√≥n o combinaci√≥n entre dos tablas de datos a partir de una variable en com√∫n o *clave* (*key*). En otras palabras, un *left join* toma dos tablas que tienen datos distintos, pero que comparten una variable o columna en com√∫n, y usa esta variable en com√∫n para **unir las observaciones de ambas tablas**.

{{< imagen "left_join_a.png" >}}
{{< bajada "Esquema de una uni√≥n entre tablas con _left join_" >}}

En el ejemplo anterior, tenemos dos tablas, ambas con tres variables distintas, pero en ambas tablas tenemos una variable que contiene informaci√≥n equivalente. En la vida real, esto podr√≠an ser nombres de personas, nombres de pa√≠ses, identificadores √∫nicos de personas o instituciones, fechas, etc√©tera. Esta variable compartida entre las tablas es la **llave** que usaremos para la uni√≥n.

Al realiazr la uni√≥n con *left join* obtenemos una nueva tabla que combina las observaciones de ambas, uniendo las filas de la primera tabla (*x*) con las filas de al segunda tabla (*y*) que se correspondan seg√∫n la llave en com√∫n.

{{< imagen "left_join_b.png" >}}
{{< bajada "Esquema del resultado del _left join_" >}}

## Ejemplo de una uni√≥n de tablas en R

Para unir dos tablas en R, usamos la funci√≥n `left_join()` de `{dplyr}`.

``` r
library(dplyr)
```

Primero creemos una tabla de base con datos de ejemplo.

``` r
frutas_x <- tibble(fruta = c("pera", "manzana", "uva"),
                   color = c("verde", "roja", "morada"))
```

|  fruta  | color  |
|:-------:|:------:|
|  pera   | verde  |
| manzana |  roja  |
|   uva   | morada |

En esa tabla tenemos tres observaciones que corresponden a animales, descritos en la primera columna, y una segunda columna con caracter√≠sticas de los mismos.

Ahora creemos una segunda tabla, que adem√°s de tener la misma columna que describe las frutas, agrega una nueva variable sobre las frutitas üçêüçéüçá

``` r
frutas_y <- tibble(fruta = c("pera", "manzana", "uva"),
                   sabor = c("deliciosa", "buena", "ricolina"))
```

|  fruta  |   sabor   |
|:-------:|:---------:|
|  pera   | deliciosa |
| manzana |   buena   |
|   uva   | ricolina  |

Dado que ambas tablas comparten la variable `fruta`, si hacemos un *left join* ambas tablas se cruzar√°n en base a esta variable, resultando en una tabla nueva:

``` r
frutas_2 <- left_join(frutas_x, frutas_y)
```

    Joining with `by = join_by(fruta)`

|  fruta  | color  |   sabor   |
|:-------:|:------:|:---------:|
|  pera   | verde  | deliciosa |
| manzana |  roja  |   buena   |
|   uva   | morada | ricolina  |

El resultado de la uni√≥n es una nueva tabla que tiene las tres variables √∫nicas obtenidas del cruce de las dos tablas distintas. En este caso, el *left join* nos permite agregar informaci√≥n sobre una misma unidad de observaci√≥n proveniente de distintas fuentes.

## Otro ejemplo

Veamos un segundo ejemplo con m√°s filas y m√°s columnas, √©sta vez sobre animalitos üêàüêÄüêï

``` r
animales_x <- tibble(animal = c("gato", "rat√≥n", "perro", "pez"),
                     color = c("gris", "negro", "blanco", "azul"),
                     tama√±o = c(34, 16, 50, 3))
```

| animal | color  | tama√±o |
|:------:|:------:|:------:|
|  gato  |  gris  |   34   |
| rat√≥n  | negro  |   16   |
| perro  | blanco |   50   |
|  pez   |  azul  |   3    |

La primera tabla contiene los nombres de animales (identificador √∫nico), sus colores y sus medidas. La segunda tabla tambi√©n contiene nombres, pero agrega su cantidad de patas[^1] y sus edades.

``` r
animales_y <- tibble(animal = c("perro", "gato", "pez"),
                     patas = c(4, 3, 0),
                     edad = c(8, 3, 1))
```

| animal | patas | edad |
|:------:|:-----:|:----:|
| perro  |   4   |  8   |
|  gato  |   3   |  3   |
|  pez   |   0   |  1   |

Las dos tablas tienen distinta cantidad de observaciones, y adem√°s las observaciones clave (columna `animal`) que se usar√°n como llave de uni√≥n est√°n desordenadas.

Cuando los data frames tienen distinta cantidad de filas, el *orden* en que hacemos la uni√≥n es importante: en un ***left** join* la primera tabla (o izquierda) es la tabla principal, a la cual se le agregan las columnas de una segunda tabla, en base a las coincidencias de la columna clave. Por lo tanto, si unimos o cruzamos las tablas poniendo primero la tabla m√°s grande y despu√©s la m√°s peque√±a, obtendremos casos perdidos por las filas de la primera tabla que no obtuvieron coincidencias en la segunda.

``` r
animales_3 <- left_join(animales_x, animales_y)
```

    Joining with `by = join_by(animal)`

| animal | color  | tama√±o | patas | edad |
|:------:|:------:|:------:|:-----:|:----:|
|  gato  |  gris  |   34   |   3   |  3   |
| rat√≥n  | negro  |   16   |  NA   |  NA  |
| perro  | blanco |   50   |   4   |  8   |
|  pez   |  azul  |   3    |   0   |  1   |

Como podemos ver, obtenemos celdas con `NA` en la observaci√≥n *rat√≥n*, debido a que en la segunda tabla (`animales_y`) no hab√≠an datos sobre este animalito. Una pena üòî

Tambi√©n ser√≠a una opci√≥n hacer el cruce al rev√©s, poniendo primero la tabla `animales_y` (3 filas) y despu√©s `animales_x` (4 filas), con el objetivo de que las observaciones de la tabla `animales_x` complementen las observaciones de `animales_y` donde hayan coincidencias, y descartando los casos que no tienen en com√∫n:

``` r
animales_3 <- left_join(animales_y, animales_x)
```

    Joining with `by = join_by(animal)`

| animal | patas | edad | color  | tama√±o |
|:------:|:-----:|:----:|:------:|:------:|
| perro  |   4   |  8   | blanco |   50   |
|  gato  |   3   |  3   |  gris  |   34   |
|  pez   |   0   |  1   |  azul  |   3    |

Ahora no tenemos datos perdidos, porque si bien `animales_x` ten√≠a m√°s observaciones que `animales_y`, `animales_y` conten√≠a todas las observaciones de `animales_x` identificadas por la variable `animal`, lo que podemos confirmar [comparando las diferencias entre ambas columnas con la funci√≥n `waldo::compare()`](../../../blog/diferencias):

``` r
library(waldo)

compare(sort(animales_x$animal), 
        sort(animales_y$animal))
```

    `old`: "gato" "perro" "pez" "rat√≥n"
    `new`: "gato" "perro" "pez"        

## Caso licencias falsas

Un caso ic√≥nico de uso de *left join* fue el [estudio realizado por la Contralor√≠a General de la Rep√∫blica de Chile](https://www.biobiochile.cl/noticias/nacional/chile/2025/05/20/contraloria-detecta-que-25-mil-funcionarios-publicos-salieron-del-pais-mientras-estaban-con-licencia.shtml), donde se cruzaron bases de datos que ten√≠an en com√∫n la posibilidad de identificar funcionarios p√∫blicos:

> Se trata de un estudio a partir del cruce de informaci√≥n de las salidas del pa√≠s registradas por la Polic√≠a de Investigaciones (PDI), la base de funcionarios p√∫blicos y las licencias m√©dicas que se otorgaron entre el 2023 y 2024. (Fuente: [B√≠o B√≠o](https://www.biobiochile.cl/noticias/nacional/chile/2025/05/20/contraloria-detecta-que-25-mil-funcionarios-publicos-salieron-del-pais-mientras-estaban-con-licencia.shtml))

La hip√≥tesis ser√≠a que una persona que sale del pa√≠s durante su licencia m√©dica ser√≠a probablemente una persona que consigui√≥ una licencia falsa para tomarse vacaciones üèñÔ∏è‚òÄÔ∏è

Simulemos lo que podr√≠a haber hecho la Contralor√≠a para detectar estos casos. Asumimos que contaron con (al menos) tres bases de datos: una de funcionarios p√∫blicos, una de licencias m√©dicas, y otra de viajes al extranjero, las tres teniendo en com√∫n el RUN (c√≥digo de identificaci√≥n √∫nico de ciudadanos chilenos) para poder cruzar las personas.

``` r
options(scipen = 9999)

funcionarios <- tibble(run = c(10000001, 10000002, 10000003),
                       nombre = c("mar√≠a", "pepito", "juanito"),
                       ministerio = c("defensa", "econom√≠a", "hacienda"))
```

|   run    | nombre  | ministerio |
|:--------:|:-------:|:----------:|
| 10000001 |  mar√≠a  |  defensa   |
| 10000002 | pepito  |  econom√≠a  |
| 10000003 | juanito |  hacienda  |

Tenemos identificados tres funcionarios p√∫blicos de distintos servicios.

Luego tenemos una base de datos con licencias m√©dicas de trabajadores que pueden o no ser funcionarios p√∫blicos. Con la base de los RUN de funcionarios p√∫blicos podemos identificar si las licencias corresponden a funcionarios p√∫blicos y no a trabajadores del sector privado.

``` r
licencias <- tibble(run = c(10000001, 10000002, 10000003, 10000004),
                    licencia = c(FALSE, FALSE, TRUE, TRUE),
                    licencia_inicio = c(NA, "2024-04-10", "2024-02-04", "2010-09-18"),
                    licencia_fin = c(NA, "2024-04-13", "2024-02-18", "2030-12-31"))
```

|   run    | licencia | licencia_inicio | licencia_fin |
|:--------:|:--------:|:---------------:|:------------:|
| 10000001 |  FALSE   |       NA        |      NA      |
| 10000002 |  FALSE   |   2024-04-10    |  2024-04-13  |
| 10000003 |   TRUE   |   2024-02-04    |  2024-02-18  |
| 10000004 |   TRUE   |   2010-09-18    |  2030-12-31  |

Lo importante de esta tabla es que tenemos una fecha de inicio y una fecha de fin de la licencia m√©dica.

Finalmente tenemos la informaci√≥n de salidas del pa√≠s de distintas personas, que pueden o no ser funcionarios p√∫blicos, y que pueden o no haber estado con licencia m√©dica ü§î

``` r
viajes <- tibble(run = c(10000005, 10000001, 10000002, 10000003, 10000008),
                 viaje_destino = c("Bolivia", "Per√∫", "Argentina", "Italia", "Espa√±a"),
                 viaje_fecha = c("2021-01-06", "2021-02-15", "2023-06-23", "2024-02-09", "2025-08-17")
)
```

|   run    | viaje_destino | viaje_fecha |
|:--------:|:-------------:|:-----------:|
| 10000005 |    Bolivia    | 2021-01-06  |
| 10000001 |     Per√∫      | 2021-02-15  |
| 10000002 |   Argentina   | 2023-06-23  |
| 10000003 |    Italia     | 2024-02-09  |
| 10000008 |    Espa√±a     | 2025-08-17  |

Ahora que tenemos datos simulados, lo primero ser√≠a **filtrar las licencias m√©dicas** para que solamente correspondan con funcionarios p√∫blicos (tambi√©n podr√≠a hacerce con `left_join()` pero creo que es m√°s pertinente un filtro)

``` r
licencias_f <- licencias |> 
  # s√≥lo funcionarios p√∫blicos
  filter(run %in% funcionarios$run)
```

Luego, **cruzamos los datos** de licencias de funcionarios p√∫blicos con el registro de salidas del pa√≠s:

``` r
# cruzar con viajes
cruce <- licencias_f |> 
  left_join(viajes, join_by(run))
```

Finalmente revisamos si los viajes fueron durante el tiempo de licencia m√©dica, y si los viajes fueron fuera del pa√≠s. Podemos hacer esto con un filtro, o preferentemente creando una columna nueva (`irregular`) que indique si se cumple o no la evaluaci√≥n.

``` r
# revisar si viajaron fuera del pa√≠s durante licencia
resultado <- cruce |>
  # crear una nueva variable
  mutate(irregular = 
           licencia == TRUE & # personas on licencia
           viaje_destino != "Chile" & # viajes fuera de Chile
           between(viaje_fecha, 
                   licencia_inicio, licencia_fin) # viaje durante el tiempo de licencia
  ) |> 
  select(-viaje_destino)
```

|   run    | licencia | licencia_inicio | licencia_fin | viaje_fecha | irregular |
|:--------:|:--------:|:---------------:|:------------:|:-----------:|:---------:|
| 10000001 |  FALSE   |       NA        |      NA      | 2021-02-15  |   FALSE   |
| 10000002 |  FALSE   |   2024-04-10    |  2024-04-13  | 2023-06-23  |   FALSE   |
| 10000003 |   TRUE   |   2024-02-04    |  2024-02-18  | 2024-02-09  |   TRUE    |

‚ö†Ô∏è Detectamos un caso de funcionario p√∫blico que viaj√≥ fuera del pa√≠s durante su licencia m√©dica! La √∫ltima columna marca `TRUE` si se trata de un caso irregular.

## Conclusi√≥n

Podemos usar `left_join()` para **completar los datos** sobre nuestra unidad de an√°lisis si la informaci√≥n viene diseminada en distintas tablas o archivos. Pero tambi√©n podemos utilizarla para **complementar datos** desde distintas fuentes, aumentando la informaci√≥n que tenemos sobre las observaciones que estemos estudiando, o bien, para realizar **cruces de informaci√≥n** que nos entreguen coincidencias relevantes.

{{< cafecito >}}
{{< cursos >}}

[^1]: el gatito lamentablemente sufri√≥ un accidente y perdi√≥ una patita trasera üòø
