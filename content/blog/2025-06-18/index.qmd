---
title: Gr치ficos para identificar datos outliers o an칩malos en R
author: Basti치n Olea Herrera
date: '2025-06-18'
slug: []
categories: []
format:
  hugo-md:
    output-file: "index"
    output-ext: "md"
tags:
  - limpieza de datos
  - ggplot2
  - gr치ficos
  - visualizaci칩n de datos
  - estad칤stica
excerpt: Los datos an칩malos o _outliers_ son datos que se alejan considerablemente de los dem치s. Crearemos un dataset simulando datos outliers y luego mostraremos algunas formas de visualizarlos en `{ggplot2}`, incluyendo un gr치fico interactivo con `{ggiraph}` donde podemos poner el cursor sobre las observaciones del gr치fico para obtener m치s informaci칩n.
---

Los datos an칩malos o _outliers_ son datos que se alejan considerablemente de los dem치s. Estos datos pueden resultar problem치ticos para ciertos an치lisis, pueden ser indicio de errores en la recolecci칩n o limpieza de datos, o pueden requerir que tomemos ciertas decisiones para corregirlos o excluirlos.

En este post **simularemos un dataset** con datos an칩malos, y luego mostraremos algunas formas de **visualizaci칩n de datos an칩malos** [en `{ggplot2}`](/tags/ggplot2/) para tomar decisiones al respecto. Al final crearemos un **gr치fico interactivo** [con `{ggiraph}`](https://davidgohel.github.io/ggiraph/) que permita poner el cursor sobre las observaciones para obtener m치s informaci칩n.

----

Primero creemos un conjunto de datos que contenga n칰meros al azar, 90 n칰meros entre 1 y 100, y 10 n칰meros m치s grandes, para que sean nuestros outliers simulados:
```{r}
#| message: false
library(dplyr)
library(ggplot2)

set.seed(1993)

valor <- c(sample(1:100, size = 90), # n칰meros al azar
           sample(120:190, size = 10)) # outliers
```

Obtenemos un vector con los dos conjuntos de n칰meros al azar.

Con la funci칩n `tibble()` convertimos el vector de n칰meros en una columna de un dataframe, y usando nuevamente `sample()` crearemos dos columnas con palabras al azar para complementar estos datos simulados:

```{r}
datos <- tibble(valor) |> 
  # procesar datos por fila en vez de por la columna entera (vectorizaci칩n)
  rowwise() |> 
  # por fila, elegir tres s칤labas al azar y unirlas en un s칩lo texto, que ser치 el "nombre" de las observaciones
  mutate(nombre = sample(c("ma", "pa", "che", "cha"), 3, F) |> paste(collapse = "")) |> 
  # desagrupar y crear otra variable con trres valores posibles, y que por lo tanto distribuya los datos en tres grupos
  ungroup() |>
  mutate(grupo = sample(c("ma", "pa", "che"), n(), T))

datos
```

```{r}
sample(c("ma", "pa", "che", "cha"), 3, F) |> paste(collapse = "")
```

## Detecci칩n de datos an칩malos

Para identificar los _outliers_, utilizaremos el criterio del **rango intercuart칤lico.** El rango intercuart칤lico se calcula con la funci칩n `IQR()` y es el rango de los datos entre el primer y tercer cuartil (el percentil 25 y el percentil 75; es decir, la diferencia entre el dato ubicado en el 75% mayor y el 25% mayor de la distribuci칩n de los datos). 

En otras palabras, el _IQR_ es una cifra que indica qu칠 tanta distancia existe en la "mitad" de tus datos, si los esparcieras todos en una distribuci칩n, como aparece en el siguiente gr치fico[^4]. 

[^4]: El c칩digo para este gr치fico [est치 disponible en este Gist.](https://gist.github.com/bastianolea/6f26f302f44fe546bebdd61f6134c4c5)


```{r}
#| fig.height: 3
#| echo: false
set.seed(1234)

x <- rnorm(1000)
y <- dnorm(x)
df <- tibble(x, y)
q_1 <- quantile(x, .25)
q_3 <- quantile(x, .73)

df |> 
  ggplot() +
  aes(x, y) +
  geom_line() +
  geom_vline(xintercept = c(q_1, q_3), linetype = "longdash") +
  annotate(geom = "rect", xmin = q_1, xmax = q_3, ymin = 0, ymax = max(y)*1.05, fill = "black", alpha = 0.1) +
  annotate(geom = "label", x = c(q_1, q_3), y = 0, label = c("1 (25%)", "3 (75%)")) +
  scale_y_continuous(expand = expansion(c(0.1, 0.1))) +
  theme_void()
```

Luego, el rango intercuart칤lico se multiplica por 1,5, y se suma al valor del tercer cuartil (percentil 75), de modo que se identifiquen como _outliers_ los datos que sean mayores[^3] al tercer cuartil m치s 1,5 veces el rango intercuart칤lico. Puedes calcular cualquier percentil de un vector o columna con la funci칩n `quantile(x, .75)`, donde el n칰mero identifica al percentil.

[^3]: En este ejemplo solamente buscaremos outliers que est칠n _por sobre_ la distribuci칩n de los datos, pero si queremos buscar datos outliers _por debajo_; es decir, valores peque침os an칩malos, la f칩rmula es la misma pero restando el `1.5 * IQR` al primer cuartil.

Aplicamos el c치lculo a la variable `valor`:

```{r}
datos_outliers <- datos |> 
  mutate(umbral = quantile(valor, 0.75) + 1.5 * IQR(valor))
```

Esto nos dar치 una cifra que operar치 como el **umbral respecto del cual se clasificar치n los outliers**. Es conveniente calcular este umbral dentro del dataframe, porque si queremos calcular outliers desagregados por otra variable, simplemente mantenemos la f칩rmula y agregamos antes un `group_by()` para realizar el c치lculo por grupos.

Crearemos una columna que simplemente nos diga si los valores son mayores o menores al umbral:

```{r}
datos_outliers <- datos_outliers |> 
  mutate(outlier = valor >= umbral)

datos_outliers
```

Obtenemos la variable `outlier` con `TRUE` si es outlier, y `FALSE` si no lo es.

Ahora vamos a visualizar estos datos con el paquete `{ggplot2}`. Si necesitas una introducci칩n a esta librer칤a de visualizaci칩n de datos, [te recomiendo revisar este tutorial](/blog/r_introduccion/tutorial_visualizacion_ggplot/), donde explicamos en mayor detalle varias de estas visualizaciones.

## Gr치fico de cajas o _boxplot_

El _boxplot_ es una visualizaci칩n que en su mismo dise침o incluye la opci칩n de mostrar los outliers, as칤 que se trata de la opci칩n natural para este tipo de visualizaciones exploratorias. As칤 que con esto concluye este tutorial. Bromita 游봃

```{r}
#| fig.height: 3
#| fig.width: 8
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1) +
  # gr치fico de boxplot
  geom_boxplot(alpha = 0.4, fill = "black", 
               outlier.color = "#F94C6A", outlier.size = 4, outlier.alpha = 0.7) + # configuraci칩n de outliers
  # temas
  theme_minimal() +
  scale_y_continuous(expand = expansion(c(0.5, 0.5))) # aumentar margen del eje vertical
```

En un _boxplot_, los puntos al extremo de la caja representan los casos an칩malos. 

Pero la gracia de este tutorial es entrenar nuestras capacidades de visualizaci칩n de datos, as칤 que veamos otras formas de visualizarlos:

## Gr치fico de puntos
Una forma sencilla de visualizar outliers ser칤a simplemente visualizar las observaciones del dataser como puntos, coloreando los puntos si son outliers.
```{r}
#| fig.width: 12
#| fig.height: 3
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier) +
  # gr치fico de puntos
  geom_point(size = 4, alpha = 0.6) +
  # escala de colores
  scale_color_manual(values = c("black", "#F94C6A")) +
  # temas
  theme_minimal() +
  # ocultar leyenda
  guides(color = guide_none(),
         y =  guide_none())
```

### Puntos con dispersi칩n
Como existe una concentraci칩n densa en parte de la distribuci칩n, podemos usar la funci칩n `geom_jitter()` para que los puntos se dispersen verticalmente (`width = 0`, porque si se dispersan horizontalmente se ubicar칤an incorrectamente con respecto a su valor)

```{r}
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier) +
  # gr치fico de puntos con dispersi칩n
  geom_jitter(size = 4, alpha = 0.6, width = 0) +
  scale_color_manual(values = c("black", "#F94C6A")) +
  theme_minimal() +
  guides(color = guide_none(),
         y =  guide_none())
```

## Gr치fico de viol칤n
El gr치fico de viol칤n tambi칠n nos permite observar la distribuci칩n de los datos, pero por s칤 solo no nos muestra las observaciones exactas, por lo que no entrega informaci칩n certera sobre los outliers, sino que nos da indicios de que la distribuci칩n de los datos tiene _colas_ que podr칤an contener outliers.
```{r}
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1) +
  # gr치fico de viol칤n
  geom_violin(fill = "black", alpha = 0.4) +
  theme_minimal() +
  guides(y =  guide_none()) # ocultar eje y
```

## Combinar visualizaciones
Una buena opci칩n es combinar las visualizaciones anteriores en una sola. De fondo podemos poner la distribuci칩n de los datos con `geom_violin()`, y encima poner los puntos de las observaciones; para las observaciones normales podemos usar `geom_jitter()` para dispersar los datos, y para los outliers, como son poquitos, `geom_point()` para que se ubiquen en concordancia con la distribuci칩n del viol칤n.

```{r}
grafico_outliers <- datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier) +
  # gr치fico de viol칤n
  geom_violin(aes(y = 1, x = valor), 
              inherit.aes = F,
              alpha = 0.2, lwd = 0.1, fill = "black") +
  # puntos para los outliers
  geom_point(data = ~filter(.x, outlier), # s칩lo para observaciones que son outlier
             size = 4, alpha = 0.6) +
  # puntos dispersados para el resto de los datos
  geom_jitter(data = ~filter(.x, !outlier), # s칩lo para observaciones que no son outlier
              size = 4, alpha = 0.6) +
  # escala de colores
  scale_color_manual(values = c("black", "#F94C6A")) +
  # temas
  theme_minimal() +
  theme(axis.title = element_blank()) +
  guides(color = guide_none(),
         y =  guide_none()) +
  scale_y_continuous(expand = expansion(c(0.2, 0.2))) # aumentar margen del eje vertical

grafico_outliers
```

Para combinar estas visualizaciones, aprovechamos la capacidad de `{ggplot2}` de especificar los datos que se usan en cada capa o geometr칤a de la visualizaci칩n por medio del argumento `data`. Normalmente, el argumento `data` se rellena por defecto con los datos que entregamos a la funci칩n `ggplot()`, pero si especificamos el argumento podemos hacer que cada capa use datos completamente distintos. En nuestro caso, no queremos datos distintos, sino **aplicar filtros a los datos de cada capa**, lo que se logra con `data = ~filter(.x, ...)`[^1], donde `...` ser칤a el filtro que necesitemos. En la visualizaci칩n anterior, queremos que `geom_point()` s칩lo muestre los datos que son `outlier == FALSE`, y que `geom_jitter()` s칩lo muestre los datos que son `outlier == TRUE`[^2]. 

[^1]: Esto funciona porque, al anteponer la colita de chancho (`~`) a la funci칩n, creamos una _funci칩n lambda_ que reciba los datos directamente sin tener que especificar el nombre del objeto (conveniente, por ejemplo, si pasaste directo de modificar los datos a hacer el gr치fico sin crear un objeto intermedio).
[^2]: En R, decir `variable == TRUE` es lo mismo que decir simplemente `variable`, porque `variable` _es_ `TRUE`; o sea que puedes hacer `filter(variable)` en vez de `filter(variable == TRUE)`, y de la misma forma, `filter(!variable)` en vez de `filter(variable == FALSE)`.

```{r}
data = ~filter(.x, outlier)
```


### Etiquetas de texto
Al identificar outliers, una buena opci칩n es mostrar etiquetas de texto para estos casos con `geom_text()`. De este modo podemos identificar exactamente a qu칠 observaciones corresponden las anomal칤as. En el caso de que fueran muchas etiquetas, podemos usar `geom_text_repel()` [del paquete `{ggrepel}`](https://ggrepel.slowkow.com) para que las etiquetas de texto se acomoden si es que caen encima de otras.

```{r}
library(ggrepel)

grafico_outliers <- grafico_outliers + 
  # agregar texto al gr치fico anterior
  ggrepel::geom_text_repel(data = ~filter(.x, outlier), # s칩lo para observaciones que son outlier
                           aes(label = nombre), # variable con el texto a mostrar
                           fontface = "bold", size = 4, point.padding = 4, angle = 90, hjust = 0) 

grafico_outliers
```

Ahora sabemos que _mapacha, pachache, chepama_ y _chachema_ son outliers 游뱓

### Dividir por grupos
Otra forma de afinar el an치lisis es separar la visualizaci칩n en los valores de la variable de agrupaci칩n que tengamos con `facet_wrap()`. En este caso, como la variable `grupo` tiene 3 valores posibles, se multiplica la visualizaci칩n por tres.

```{r}
#| fig.height: 9
grafico_outliers <- grafico_outliers +
  # separar gr치fico en facetas seg칰n la variable grupo
  facet_wrap(~grupo, ncol = 1, scales = "fixed") +
  theme(strip.text = element_text(face = "bold")) # t칤tulo de facetas en negrita

grafico_outliers
```


## Gr치fico interactivo
Para mejorar la exploraci칩n de los datos podemos convertir f치cilmente cualquier gr치fico de `{ggplot2}` en gr치ficos interactivos gracias [al paquete `{ggiraph}`](https://davidgohel.github.io/ggiraph/). Principalmente, lo que agregaremos son _tooltips_ o cajas emergentes que aparecer치n cuando se pose el cursor sobre un punto del gr치fico y que muestren informaci칩n extra.

Con `{ggiraph}` solamente se requieren cambios m칤nimos para volver interactivo cualquier gr치fico. Entre ellos es agregar `_interactive` a las funciones que crean las geometr칤as del gr치fico:

- Pasar de `geom_point()` a `geom_point_interactive()`
- Pasar de `geom_jitter()` a `geom_jitter_interactive()`

Habiendo hecho este cambio, dentro de las geometr칤as `geom_x_interactive()` ahora podremos definir la est칠tica `tooltip` dentro de `aes()` para que **aparezca contenido cuando se ponga el cursor sobre los elementos del gr치fico.** En este caso, haremos que los _tooltips_ muestren el nombre de la observaci칩n y su valor, y la palabra _outlier_ si corresponde. Tambi칠n podemos agregar `html` para dar estilo al texto; por ejemplo, las etiquetas `<b>` para letra negrita.

Si queremos que los puntos del gr치fico **se iluminen o cambien de color al poner el cursor encima**, adicionalmente tenemos que definir la est칠tica `data_id` que identifique de forma 칰nica los elementos del gr치fico (puede servir para hacer que varios se iluminen al mismo tiempo si elijes una variable que no identifique de forma 칰nica los valores).

Copiamos el c칩digo anterior y hacemos los cambios apropiados al gr치fico:
```{r}
library(ggiraph)

grafico_outliers_interactivo <- datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier,
      # variable que identifica de forma 칰nica a los elementos del gr치fico
      data_id = nombre) + 
  geom_violin(aes(y = 1, x = valor), 
              inherit.aes = F, alpha = 0.2, lwd = 0.1, fill = "black") +
  # puntos para los outliers
  ggiraph::geom_point_interactive(data = ~filter(.x, outlier), 
                                  # texto "outlier" con el valor
                                  aes(tooltip = paste("<b>outlier:</b> ", valor, sep = "")), 
                                  size = 4, alpha = 0.6) +
  # puntos dispersados para el resto de los datos
  ggiraph::geom_jitter_interactive(data = ~filter(.x, !outlier), 
                                   # nombre de observaci칩n y valor
                                   aes(tooltip = paste("<b>", nombre, ":</b> ", valor, sep = "")), 
                                   size = 4, alpha = 0.6) +
  ggrepel::geom_text_repel(data = ~filter(.x, outlier),
                           aes(label = nombre),
                           fontface = "bold", size = 4, point.padding = 4, angle = 90, hjust = 0) +
  scale_color_manual(values = c("black", "#F94C6A")) +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  guides(color = guide_none(),
         y =  guide_none()) +
  scale_y_continuous(expand = expansion(c(0.2, 0.2))) # aumentar margen del eje vertical
```

Finalmente, para permitir la interactividad del gr치fico, debemos generarlo con la funci칩n `girafe()`, la cual recibe el objeto con el gr치fico adem치s de varias opciones para personalizar la visualizaci칩n:

```{r}
#| output: asis

girafe(ggobj = grafico_outliers_interactivo, 
       # dimensiones del gr치fico
       width_svg = 9, height_svg = 4,
       # opciones para los tooltips
       options = list(
         # ocultar barra de opciones
         opts_toolbar(hidden = "selection", saveaspng = FALSE),
         # color al poner el cursor encima
         opts_hover(css = "fill: white; stroke: black;"),
         # personalizar la apariencia del tooltip
         opts_tooltip(opacity = 0.7, use_fill = TRUE,
                      css = "font-family: sans-serif; font-size: 70%; color: white; padding: 4px; border-radius: 5px;"))
)
```

Toca o posa el cursor sobre un punto para ver la informaci칩n extra! 쯇uedes encontrar el punto que dice _pamache_? 游붛

----

{{< cursos >}}

{{< cafecito >}}
