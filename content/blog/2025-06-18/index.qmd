---
title: Identificar datos outliers o an칩malos en R mediante gr치ficos
author: Basti치n Olea Herrera
date: '2025-06-18'
slug: []
categories: []
format:
  hugo-md:
    output-file: "index"
    output-ext: "md"
tags:
  - limpieza de datos
  - ggplot2
  - gr치ficos
  - visualizaci칩n de datos
  - estad칤stica
excerpt: Los datos an칩malos o _outliers_ son datos que se alejan considerablemente de los dem치s. Crearemos un dataset simulando datos outliers y luego mostraremos algunas formas de visualizarlos en `{ggplot2}, incluyendo un gr치fico interactivo con `{ggiraph}` que permita poner el cursor sobre las observaciones para obtener m치s informaci칩n.
---

Los datos an칩malos o _outliers_ son datos que se alejan considerablemente de los dem치s. Estos datos pueden resultar problem치ticos para ciertos an치lisis, pueden ser indicio de errores en la recolecci칩n o limpieza de datos, o pueden requerir que tomemos ciertas decisiones para corregirlos o excluirlos.

En este post crearemos un dataset con datos outliers y luego mostraremos algunas formas de visualizarlos [en `{ggplot2}`](/tags/ggplot2/) para tomar decisiones al respecto. Al final crearemos un gr치fico interactivo [con `{ggiraph}`](https://davidgohel.github.io/ggiraph/) que permita poner el cursor sobre las observaciones para obtener m치s informaci칩n.

----

Primero creemos un conjunto de datos que contenga n칰meros al azar, 90 n칰meros entre 1 y 100, y 10 n칰meros m치s grandes, para que sean nuestros outliers simulados:
```{r}
#| message: false
library(dplyr)
library(ggplot2)

set.seed(1993)

valor <- c(sample(1:100, size = 90), # n칰meros al azar
           sample(120:190, size = 10)) # outliers
```

Obtenemos un vector con los dos conjuntos de n칰meros al azar.

Con la funci칩n `tibble()` convertimos el vector en una columna de un dataframe nuevo, y usando nuevamente `sample()` crearemos dos columnas con palabras al azar para complementar estos datos simulados:

```{r}
datos <- tibble(valor) |> 
  # procesar por fila
  rowwise() |> 
  # por fila, elegir tres s칤labas al azar y unirlas en un texto
  mutate(nombre = sample(c("ma", "pa", "che", "cha"), 3, F) |> paste(collapse = "")) |> 
  # desagrupar y creat otra columna que distribuya los datos en tres grupos
  ungroup() |>
  mutate(grupo = sample(c("ma", "pa", "che"), n(), T))

datos
```
Para identificar los _outliers_, utilizaremos el criterio del rango intercuart칤lico. El rango intercuart칤lico es el rango de los datos entre el primer y tercer cuartil (el percentil 25 y el percentil 75; es decir, la diferencia entre el dato ubicado en el 75% mayor y el 25% mayor de la distribuci칩n de los datos). Luego, este valor se multiplica por 1,5, y se suma al valor del tercer cuartil (percentil 75), de modo que se identifiquen como _outliers_ los datos que sean mayores al tercer cuartil m치s 1,5 veces el rango intercuart칤lico.

```{r}
datos_outliers <- datos |> 
  mutate(umbral = quantile(valor, 0.75) + 1.5 * IQR(valor))
```
Esto nos dar치 una cifra que operar치 como el umbral respecto del cual, si un valor es mayor a esta cifra, se clasificar치 como outlier. Es conveniente calcular este umbral dentro del dataframe, porque si queremos calcular outliers desagregados por otra variable, simplemente mantenemos la f칩rmula y agregamos antes un `group_by()` para realizar el c치lculo por grupos.

Crearemos una columna que simplemente nos diga si los valores son mayores o menores al umbral:

```{r}
datos_outliers <- datos_outliers |> 
  mutate(outlier = valor >= umbral)

datos_outliers
```

Obtenemos la variable `outlier` con `TRUE` si es outlier, y `FALSE` si no lo es.

Ahora vamos a visualizar estos datos con el paquete `{ggplot2}`. Si necesitas una introducci칩n a esta librer칤a de visualizaci칩n de datos, [te recomiendo revisar este tutorial](/blog/r_introduccion/tutorial_visualizacion_ggplot/), donde explicamos en mayor detalle varias de estas visualizaciones.

## Gr치fico de cajas o _boxplot_

El _boxplot_ es una visualizaci칩n que en su mismo dise침o incluye la opci칩n de mostrar los outliers, as칤 que se trata de la opci칩n natural para este tipo de visualizaciones exploratorias.

```{r}
#| fig.height: 3
#| fig.width: 8
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1) +
  # gr치fico de boxplot
  geom_boxplot(alpha = 0.4, fill = "black", 
               outlier.color = "#F94C6A", outlier.size = 4, outlier.alpha = 0.7) + # configuraci칩n de outliers
  # temas
  theme_minimal() +
  scale_y_continuous(expand = expansion(c(0.5, 0.5))) # aumentar margen del eje vertical
```

En un _boxplot_, los puntos al extremo de la caja representan los casos an칩malos. 

Pero la gracia de este tutorial es entrenar nuestras capacidades de visualizaci칩n de datos, as칤 que veamos otras formas de visualizarlos:

## Gr치fico de puntos
Una forma sencilla de visualizar outliers ser칤a simplemente visualizar las observaciones del dataser como puntos, coloreando los puntos si son outliers.
```{r}
#| fig.width: 12
#| fig.height: 3
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier) +
  # gr치fico de puntos
  geom_point(size = 4, alpha = 0.6) +
  # escala de colores
  scale_color_manual(values = c("black", "#F94C6A")) +
  # temas
  theme_minimal() +
  # ocultar leyenda
  guides(color = guide_none(),
         y =  guide_none())
```

### Puntos con dispersi칩n
Como existe una concentraci칩n densa en parte de la distribuci칩n, podemos usar la funci칩n `geom_jitter()` para que los puntos se dispersen verticalmente (`width = 0`, porque si se dispersan horizontalmente se ubicar칤an incorrectamente con respecto a su valor)

```{r}
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier) +
  # gr치fico de puntos con dispersi칩n
  geom_jitter(size = 4, alpha = 0.6, width = 0) +
  scale_color_manual(values = c("black", "#F94C6A")) +
  theme_minimal() +
  guides(color = guide_none(),
         y =  guide_none())
```

## Gr치fico de viol칤n
El gr치fico de viol칤n tambi칠n nos permite observar la distribuci칩n de los datos, pero por s칤 solo no nos muestra las observaciones exactas, por lo que no entrega informaci칩n certera sobre los outliers, sino que nos da indicios de que la distribuci칩n de los datos tiene _colas_ que podr칤an contener outliers.
```{r}
datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1) +
  # gr치fico de viol칤n
  geom_violin(fill = "black", alpha = 0.4) +
  theme_minimal() +
  guides(y =  guide_none()) # ocultar eje y
```

## Combinar visualizaciones
Una buena opci칩n es combinar las visualizaciones anteriores en una sola. De fondo podemos poner la distribuci칩n de los datos con `geom_violin()`, y encima poner los puntos de las observaciones; para las observaciones normales podemos usar `geom_jitter()` para dispersar los datos, y para los outliers, como son poquitos, `geom_point()` para que se ubiquen en concordancia con la distribuci칩n del viol칤n.

```{r}
grafico_outliers <- datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier) +
  # gr치fico de viol칤n
  geom_violin(aes(y = 1, x = valor), 
              inherit.aes = F,
              alpha = 0.2, lwd = 0.1, fill = "black") +
  # puntos para los outliers
  geom_point(data = ~filter(.x, outlier), # s칩lo para observaciones que son outlier
             size = 4, alpha = 0.6) +
  # puntos dispersados para el resto de los datos
  geom_jitter(data = ~filter(.x, !outlier), # s칩lo para observaciones que no son outlier
              size = 4, alpha = 0.6) +
  # escala de colores
  scale_color_manual(values = c("black", "#F94C6A")) +
  # temas
  theme_minimal() +
  theme(axis.title = element_blank()) +
  guides(color = guide_none(),
         y =  guide_none())

grafico_outliers
```

Para combinar estas visualizaciones, aprovechamos la capacidad de `{ggplot2}` de especificar los datos que se usan en cada capa o geometr칤a de la visualizaci칩n por medio del argumento `data`. Normalmente, el argumento `data` se rellena por defecto con los datos que entregamos a la funci칩n `ggplot()`, pero si especificamos el argumento podemos hacer que cada capa use datos completamente distintos. En nuestro caso, no queremos datos distintos, sino **aplicar filtros a los datos de cada capa**, lo que se logra con `data = ~filter(.x, ...)`[^1], donde `...` ser칤a el filtro que necesitemos. En la visualizaci칩n anterior, queremos que `geom_point()` s칩lo muestre los datos que son `outlier == FALSE`, y que `geom_jitter()` s칩lo muestre los datos que son `outlier == TRUE`[^2]. 

[^1]: Esto funciona porque, al anteponer la colita de chancho (`~`) a la funci칩n, creamos una _funci칩n lambda_ que reciba los datos directamente sin tener que especificar el nombre del objeto (conveniente, por ejemplo, si pasaste directo de modificar los datos a hacer el gr치fico sin crear un objeto intermedio).
[^2]: En R, decir `variable == TRUE` es lo mismo que decir simplemente `variable`, porque `variable` _es_ `TRUE`; o sea que puedes hacer `filter(variable)` en vez de `filter(variable == TRUE)`, y de la misma forma, `filter(!variable)` en vez de `filter(variable == FALSE)`.

```{r}
data = ~filter(.x, outlier)
```


### Etiquetas de texto
Al identificar outliers, una buena opci칩n es mostrar etiquetas de texto para estos casos con `geom_text()`. De este modo podemos identificar exactamente a qu칠 observaciones corresponden las anomal칤as. En el caso de que fueran muchas etiquetas, podemos usar `geom_text_repel()` para que las etiquetas se muevan si es que caen encima de otras.

```{r}
library(ggrepel)

grafico_outliers <- grafico_outliers + 
  # agregar texto al gr치fico anterior
  ggrepel::geom_text_repel(data = ~filter(.x, outlier), # s칩lo para observaciones que son outlier
                  aes(label = nombre), # variable con el texto a mostrar
                  fontface = "bold", size = 4, point.padding = 4, angle = 90, hjust = 0) 

grafico_outliers
```

Ahora sabemos que _mapacha, pachache, chepama_ y _chachema_ son outliers.

### Dividir por grupos
Otra forma de afinar el an치lisis es separar la visualizaci칩n en los valores de la variable de agrupaci칩n que tengamos con `facet_wrap()`. En este caso, como la variable `grupo` tiene 3 valores posibles, se multiplica la visualizaci칩n por tres.

```{r}
#| fig.height: 9
grafico_outliers <- grafico_outliers +
  # separar gr치fico en facetas seg칰n la variable grupo
  facet_wrap(~grupo, ncol = 1, scales = "fixed") +
  theme(strip.text = element_text(face = "bold")) # t칤tulo de facetas en negrita

grafico_outliers
```


## Gr치fico interactivo
Para mejorar la exploraci칩n de los datos podemos convertir f치cilmente cualquier gr치fico de `{ggplot2}` en gr치ficos interactivos gracias [al paquete `{ggiraph}`](https://davidgohel.github.io/ggiraph/). Principalmente, lo que agregaremos son _tooltips_ o cajas emergentes que aparecer치n cuando se pose el cursor sobre un punto del gr치fico y que muestren informaci칩n extra.

Con `{ggiraph}` solamente se requieren cambios m칤nimos para volver interactivo caulquier gr치fico. Entre ellos es agregar `_interactive` a las funciones que crean las geometr칤as del gr치fico:

- Pasar de `geom_point()` a `geom_point_interactive()`
- Pasar de `geom_jitter()` a `geom_jitter_interactive()`

Habiendo hecho este cambio, dentro de las geometr칤as `geom_x_interactive()` podemos definir la est칠tica `tooltip` dentro de `aes()` para especificar el contenido que aparecer치 cuando se ponga el cursor sobre los elementos del gr치fico. En este caso, haremos que los _tooltips_ muestren el nombre de la observaci칩n y su valor, y la palabra _outlier_ si corresponde.

Copiamos el c칩digo anterior y hacemos los cambios apropiados al gr치fico:
```{r}
library(ggiraph)

grafico_outliers_interactivo <- datos_outliers |> 
  ggplot() +
  aes(x = valor, y = 1, color = outlier) +
  geom_violin(aes(y = 1, x = valor), 
              inherit.aes = F,
              alpha = 0.2, lwd = 0.1, fill = "black") +
  # puntos para los outliers
  ggiraph::geom_point_interactive(data = ~filter(.x, outlier), 
                         aes(tooltip = paste("outlier: ", valor, sep = "")), # texto "outlier" con el valor
                         size = 4, alpha = 0.6) +
  # puntos dispersados para el resto de los datos
  ggiraph::geom_jitter_interactive(data = ~filter(.x, !outlier), 
                          aes(tooltip = paste(nombre, ": ", valor, sep = "")), # nombre de observaci칩n y valor
                          size = 4, alpha = 0.6) +
  ggrepel::geom_text_repel(data = ~filter(.x, outlier),
                  aes(label = nombre),
                  fontface = "bold", size = 4, point.padding = 4, angle = 90, hjust = 0) +
  scale_color_manual(values = c("black", "#F94C6A")) +
  theme_minimal() +
  theme(axis.title = element_blank()) +
  guides(color = guide_none(),
         y =  guide_none())
```

Finalmente, para permitir la interactividad del gr치fico, debemos generarlo con la funci칩n `girafe()`, la cual recibe el objeto con el gr치fico adem치s de varias opciones para personalizar la visualizaci칩n:

```{r}
#| output: asis
girafe(ggobj = grafico_outliers_interactivo, 
       # dimensiones del gr치fico
       width_svg = 9, height_svg = 4,
       # opciones para los tooltips
       options = list(
         # ocultar barra de opciones
         opts_toolbar(hidden = "selection", saveaspng = FALSE),
         # personalizar la apariencia del tooltip
         opts_tooltip(opacity = 0.7, use_fill = TRUE,
                      css = "font-family: sans-serif; font-size: 70%; color: white; padding: 4px; border-radius: 5px;"))
       )
```

Toca o posa el cursor sobre un punto para ver la informaci칩n extra! 쯇uedes encontrar el punto que dice _pamache_? 游붛

----

{{< cafecito >}}
