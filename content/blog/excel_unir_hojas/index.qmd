---
title: Cargar y unir datos de m칰ltiples hojas de Excel con R
author: Basti치n Olea Herrera
date: '2025-12-09'
draft: false
slug: []
categories: []
tags:
  - Excel
  - limpieza de datos
  - datos
format:
  hugo-md:
    output-file: index
    output-ext: md
links:
  - icon: github
    icon_pack: fab
    name: C칩digo
    url: https://gist.github.com/bastianolea/5c896dab18924a9cc0346fd7570ee28b
excerpt: "Las hojas de Excel pueden ser c칩modas para organizar informaci칩n, pero no mucho para procesarla o analizarla. Por lo mismo, una de las operaciones iniciales de limpieza de datos suele ser unir datos que vienen repartidos en varias hojas de Excel. Veamos c칩mo se hace paso a paso. Usaremos el paquete `{readxl}` para leer los datos, `{dplyr}` para manipular y combinar las hojas, y `{purrr}` para realizar operaciones sobre todas las hojas de forma autom치tica."
---

Las hojas de Excel pueden ser c칩modas para organizar informaci칩n, pero no mucho para procesarla o analizarla. Por lo mismo, una de las operaciones iniciales de limpieza de datos suele ser **unir datos que vienen repartidos en varias hojas de Excel**. 

En este tutorial vamos a ver c칩mo se hace paso a paso. Usaremos el paquete `{readxl}` para leer los datos, `{dplyr}` para manipular y combinar las hojas, y `{purrr}` para realizar operaciones sobre todas las hojas de forma autom치tica.


## Datos

Como ejemplo, usaremos un archivo de Excel con datos falsos, que puedes descargar a continuaci칩n:

{{< boton "Descargar datos falsos" "/blog/excel_unir_hojas/datos_falsos.xlsx" "fas fa-download" >}}

{{< detalles "Ver c칩digo para generar los datos falsos" >}}


```{r}
#| message: false
#| eval: false

library(purrr)
library(dplyr)

nombres_hojas <- paste("hoja", 1:20)

# crear una lista con tablas de datos sint칠ticos
datos_falsos <- map( # iterar por cada elemento
  set_names(nombres_hojas), # poner nombre a cada elemento
  ~{
    n = sample(5:30, 1) # cantidad de filas al azar
    
    # datos al azar
    datos <- tibble(variable_a  = sample(letters, n, replace = T),
                    variable_b = rnorm(n),
                    variable_c = rnorm(n),
    )
    
    # que una de las tablas sea distinta
    if (.x == "hoja 13") {
      datos <- datos |> 
        mutate(variable_c = sample(letters, n, replace = T))
    }
    
    return(datos)
  }
)

# guardar archivo
writexl::write_xlsx(datos_falsos, "datos_falsos.xlsx")
```

{{< /detalles >}}

Se trata de un archivo con 20 hojas, y tres columnas con datos al azar. La planilla de Excel se ve m치s o menos as칤:

{{< imagen "datos_falsos.png" >}}


## Cargar datos desde una hoja de Excel

Para cargar datos desde una hoja espec칤fica de un archivo Excel, usamos la funci칩n `read_excel()` del paquete `readxl`, definiendo la hoja en el argumento `sheet` (ya sea seg칰n su posici칩n o su nombre).

```{r}
library(readxl)

datos <- read_excel("datos_falsos.xlsx", sheet = 2)

head(datos)
```

Obtenemos s칩lo los datos de la hoja especificada. Esta es la base que nos permitir치 cargar desde m칰ltiples hojas.

## Unir datos desde varias hojas de Excel manualmente

La forma b치sica de unir los datos de varias hojas ser칤a repetir la lectura de datos anterior, y luego unir los objetos resultantes con `bind_rows()` de `dplyr`.


{{< info "La funci칩n `bind_rows()` une varias tablas con las mismas columnas, apil치ndolas una debajo de la otra, como una torta 游꼻" >}}



```{r}
#| message: false

# cargar hojas individualmente
datos_1 <- read_excel("datos_falsos.xlsx", sheet = 1)
datos_2 <- read_excel("datos_falsos.xlsx", sheet = 2)
datos_3 <- read_excel("datos_falsos.xlsx", sheet = 3) 

library(dplyr)

# unir todas las hojas
bind_rows(datos_1, datos_2, datos_3)
```

Pero pronto nos damos cuenta de que esto **no es sostenible**: si tenemos 20 hojas, o 50, o 100, no podemos estar copiando y pegando el mismo c칩digo una y otra vez! Ni menos crear 100 objetos distintos para cada hoja!

{{< info "Cuando repitas c칩digo 3 veces, significa que lo correcto ser칤a hacer una funci칩n o un loop" >}}

Necesitamos **automatizar** este c칩digo para aplicarlo a todas las hojas que queramos.

### Corregir diferencias entre hojas al unirlas

Pero 쯤u칠 pasa si las hojas tienen **datos inesperados**? Intentemos unir otras hojas del mismo archivo:

```{r}
#| error: true
#Se cambian los datos porque no calzan entre las dos columnas el tipo de dato, 
datos_11 <- read_excel("datos_falsos.xlsx", sheet = 11)
datos_12 <- read_excel("datos_falsos.xlsx", sheet = 12)
datos_13 <- read_excel("datos_falsos.xlsx", sheet = 13)

bind_rows(datos_11, datos_12, datos_13)
```

춰Obtenemos un error! No siempre podemos asumir que todo va a salir bien (casi nunca todo sale bien). Al unir varias hojas, si alguna viene con datos incorrectos, la uni칩n con `bind_rows()` **falla**. 

En este caso, seg칰n el error vemos que la columna `variable_c` es **distinta** en una de las hojas:

```{r}
waldo::compare(datos_12$variable_c, datos_13$variable_c)
```

Si [comparamos las columnas con `{waldo}`](/blog/waldo/), confirmamos usando que la columna `c` viene con datos tipo car치cter en una de las hojas, mientras que en las otras hojas es num칠rica, por lo que R se niega a hacer la uni칩n.

{{< info "Recordemos que las columnas s칩lo pueden ser de **un** tipo en R, por lo que no puedes mezclar n칰meros con texto en una columna!" >}}

La soluci칩n parche ser칤a **corregir los datos** en esa hoja espec칤fica, y reintentar la uni칩n:

```{r}
#| message: false
library(dplyr)

datos_13b <- datos_13 |> 
  mutate(variable_c = as.numeric(variable_c))

bind_rows(datos_11, datos_12, datos_13b)
```

춰Funciona! 

----

Ya vimos c칩mo cargar y unir varias hojas de Excel, as칤 que ahora veremos c칩mo **automatizar** este proceso para que funcione con cualquier cantidad de hojas.

## Unir datos desde varias hojas de Excel autom치ticamente

Para realizar operaciones que se repiten a lo largo de una serie de elementos (sean hojas de Excel, archivos, columnas, filas, etc), usamos [_loops_ (bucles)](/tags/loops/) para automatizar el proceso.

### Repaso de _loops_ con `purrr::map()`

Antes de seguir avanzando, haremos un repaso de _loops_ con el paquete `{purrr}`. 

{{< info "Un _loop_ o bucle en R es una estructura de control que permite repetir un bloque de c칩digo varias veces, iterando sobre una secuencia de elementos" >}}

En un loop, tenemos una **secuencia** de algo, a la cual vamos a **repetirle** una operaci칩n. Se realizan tantas operaciones o **pasos** como elementos haya en la secuencia. 

Con las funciones para _loops_ del paquete `{purrr}`, cada paso va agregando los resultados como un elemento de una lista, la cual podemos combinar al final si queremos.

Veamos un ejemplo b치sico: tenemos n칰meros del 1 al 4, y por cada n칰mero, queremos multiplicar por 10, y obtener el resultado.

```{r}
# install.packages("purrr") 
library(purrr)

# creamos una secuencia de elementos
hojas <- c(1, 2, 3, 4)

# por cada elemento de la secuencia, repetimos una operaci칩n
map(hojas,
    ~{.x * 10}
)
```

En el ejemplo anterior, iteramos sobre una **secuencia** de n칰meros del 1 al 4. Por cada n칰mero, que en cada **paso** se representa por `.x`, multiplicamos el n칰mero por 10 (`.x * 10`), y el resultado de cada paso se guarda como un elemento de una **lista**.

{{< info "Una lista en R es un objeto que puede contener varios elementos, los cuales pueden ser de distintos tipos y tama침os" >}}



### _Loop_ para cargar hojas 

Siguiendo el mismo principio del ejemplo anterior, iteramos por las hojas del 1 al 3, y dentro del _loop_, definimos que se **cargue** el archivo Excel en la hoja correspondiente a cada n칰mero de la secuencia.

Entonces, en el paso 1 se carga la hoja 1, en el paso 2 se carga la hoja 2, y as칤 sucesivamente hasta la hoja 10.

Al final le ponemos `list_rbind()` (parecido a `bind_rows()`) para que todos los elementos de la lista se unan en un s칩lo dataframe., asumiendo que todas las hojas tienen datos compatibles.

```{r}
# secuencia de hojas a cargar
hojas <- c(1:3)

# loop
datos <- map(hojas, ~{ # por cada hoja
  read_excel("datos_falsos.xlsx", sheet = .x) # cargar el archivo en la hoja correspondiente
}
)

datos
```

춰Cargamos 3 hojas! El resultado es una **lista** con tres elementos. Ahora **unimos** el resultado con `list_rbind()` para que quede una sola tabla con el contenido de cada hoja:

```{r}
datos |> list_rbind() # unir todo al final
```

Pero 쯤u칠 pasa si ampliamos la cantidad de hojas, en espec칤fico al pasar por la hoja 13 que ten칤a datos incorrectos?

```{r}
#| error: true
# secuencia de hojas a cargar
hojas <- c(1:20)

# loop
map(hojas, ~{
  read_excel("datos_falsos.xlsx", sheet = .x) 
}
) |> list_rbind() # unir todo al final
```

Error! Como vimos antes, el problema con esta hoja que ten칤a una columna distinta va a evitar que los resultados se unan al final del _loop_. 

Entonces, dentro del _loop_ podemos aplicar la misma correcci칩n que probamos antes:

```{r}
hojas <- c(1:20)

map(hojas,
    ~{
      read_excel("datos_falsos.xlsx",sheet = .x) |> 
        mutate(variable_c = as.numeric(variable_c)) # corregir columna
    }
) |> list_rbind()
```

Con este c칩digo **cargamos los datos de todas las hojas, aplicando la correcci칩n necesaria** para que los datos se puedan unir correctamente, y obtuvimos como resultado una sola tabla con todos los datos hacia abajo!

Otra opci칩n m치s espec칤fica (menos extrapolable) ser칤a aplicar la correcci칩n s칩lo a la hoja que sabemos que tiene el problema, usando una condici칩n `if` dentro del _loop_:

```{r}
#| eval: false
map(hojas,
    ~{
      datos_hoja <- read_excel("datos_falsos.xlsx",sheet = .x)
      
      if (.x == 13) { # si es la hoja 13
        datos_hoja <- datos_hoja |>
          mutate(variable_c = as.numeric(variable_c)) # corregir columna
      }
      
      return(datos_hoja)
    }
) |> list_rbind()
```

Esta forma de hacerlo es menos reutilizable, pero si te permite una mayor flexibilidad al momento de aplicar correcciones m치s complejas.

### Agregar el nombre de la hoja como una variable nueva
Si queremos agregar una **columna que indique desde qu칠 hoja vienen los datos**, primero usamos la funci칩n `excel_sheets()` para obtener los nombres de las hojas:

```{r}
# obtener nombres de las hojas
nombres_hojas <- readxl::excel_sheets("datos_falsos.xlsx")
```

Como se trata de un vector, podemos extraer sus elementos usando su posici칩n, para saber c칩mo se llama cada hoja:

```{r}
# consultar el nombre de una hoja
nombres_hojas[10]
```

Ahora que sabemos los nombres de las hojas, podemos iterar el _loop_ usando los nombres directamente (en vez de n칰meros), y aprovechar de usar el nombre en cada paso para agregar una columna que se llame `hoja`:

```{r}
datos <- map(
  nombres_hojas, # iterar por el nombre de cada hoja
  ~{
    message(.x) # decir la hoja al leerla
    
    read_excel("datos_falsos.xlsx", sheet = .x) |> 
      mutate(variable_c = as.numeric(variable_c)) |> 
      mutate(hoja = .x) # agregar nombre de hoja como columna
  }
) |> list_rbind()

# obtener 10 filas al azar
slice_sample(datos, n = 10)
```

Otra opci칩n m치s rudimentaria, pero a veces necesaria, es iterar por la posici칩n de cada hoja, y luego usar esa posici칩n para extraer el nombre de la hoja desde el vector `nombres_hojas`. Usamos `seq_along()` para obtener un vector de n칰meros sucesivos por cada elemento del objeto, e iteramos por el _loop_ siguiendo esos n칰meros. 

{{< info "La funci칩n `seq_along()` genera una secuencia de n칰meros desde 1 hasta el largo del objeto que le pasemos como argumento. Es equivalente a `1:length(x)`" >}}

Dentro del _loop_ referimos el n칰mero (`.x`) para obtener el mismo elemento del vector de nombres (`nombres_hojas[.x]`), y as칤 agregar una columna nueva con el nombre de la hoja:

```{r}
#| output: false
datos <- map(
  seq_along(nombres_hojas), # iterar por la posici칩n de cada hoja
  ~{
    message(nombres_hojas[.x]) # decir la hoja al leerla
    
    read_excel("datos_falsos.xlsx",sheet = .x) |> # cargar hoja
      mutate(variable_c = as.numeric(variable_c)) |> # correcci칩n
      mutate(hoja = nombres_hojas[.x]) # agregar nombre de hoja como columna
  }
) |> list_rbind()

head(datos)
```


### Guardar archivo resultante
Ahora que tenemos los datos de todas las hojas unidos en una sola planilla, podemos guardarlos en un nuevo archivo Excel usando la funci칩n `write_xlsx()` del paquete `writexl`:

```{r}
writexl::write_xlsx(datos, "datos_unidos.xlsx")
```


춰Y listo! Hemos aprendido a cargar y unir datos desde m칰ltiples hojas de Excel, enfrentando problemas comunes como datos incompatibles, y automatizando el proceso para cualquier cantidad de hojas.

{{< cafecito >}}

{{< cursos >}}