---
title: "Herramientas b√°sicas para programar con R"
author: Basti√°n Olea Herrera
date: '2024-11-16'
format: 
  hugo-md:
    output-file: "index"
    output-ext:  "md"
weight: 4
draft: true
series: "Introducci√≥n a R"
slug: []
categories: ["Tutoriales"]
tags:
  - dplyr
lang: es
excerpt: "En gu√≠a aprenderemos herramientas de programaci√≥n poderosas que flexibilizar√°n mucho nuestras capacidades de an√°lisis de datos, abriendo infinitas posibilidades. Con ellas, podremos crear nuevas herramientas que nos permitan hacer lo que necesitamos (funciones), condicionar lo que queremos que ocurra en nuestros procesos (controlar el flujo), y realizar operaciones repetidamente (iteraciones o loops)."
---




Esta es la segunda gu√≠a introductoria para aprender el lenguaje de programaci√≥n R orientado al an√°lisis de datos. [En la gu√≠a anterior vimos los principios m√°s fundamentales del lenguaje R](/blog/r_introduccion/r_basico/), para familiarizarnos con R y entender su funcionamiento b√°sico. En esta segunda gu√≠a, seguiremos puliendo nuestros aprendizajes para aprender herramientas de programaci√≥n poderosas que flexibilizar√°n mucho nuestras capacidades de an√°lisis de datos, abriendo infinitas posibilidades.

En esta gu√≠a, aprenderemos herramientas que nos permitir√°n a:
1. Crear herramientas que nos permitan hacer lo que necesitamos (crear **funciones**)
2. Condicionar lo que queremos que ocurra en nuestros procesos (**controlar** el flujo)
3. Hacer lo que necesitamos repetidamente (realizar iteraciones o **loops**)


----


## Crear funciones

La creaci√≥n de funciones nos abre las puertas a todo el mundo nuevo en el uso de R para analizar nuestros datos, dado que, una vez que te familiarizas con la creaci√≥n de funciones, ya no depende solamente de las herramientas existentes, sino que empiezas a hacer t√∫ quien crea nuevas herramientas adaptadas a tus propias necesidades.

La anterior tiene el enorme beneficio de permitirte personalizar las herramientas que utilices para analizar datos a tu forma de trabajo, a las especificidades de tus datos, y a las particularidades del proceso que est√©s llevando a cabo. Quiz√°s el aspecto m√°s satisfactorio de la creaci√≥n de funciones sea poder englobar un proceso largo y complejo en una funci√≥n llamada `procesar_datos()`, o poder generar un gr√°fico detallado y atractivo tan s√≥lo con llamar `graficar()`! 

Para **crear una funci√≥n** se usa, valga la redundancia, la funci√≥n `function()`. Dentro de `function()` se definen los **argumentos**, que ‚Äîcomo sabemos‚Äî son los elementos que pasamos dentro de la funci√≥n para que √©sta opere. Luego de `function()` se abren unos par√©ntesis de llave, dentro de los cuales definiremos qu√© har√° la funci√≥n con los argumentos que le entregamos, y que retornar√°. Con **retornar** nos referimos a el producto final de esta funci√≥n; es decir, lo que nos entrega al ejecutarla.
 
Definamos el nombre, los argumentos, y el cuerpo de una nueva funci√≥n:



```{r}
multiplicar_mil <- function(cifra) {
  cifra * 1000
}
```



En este ejemplo, estamos creando una funci√≥n que se llamar√° `multiplicar_mil()`. La funci√≥n tendr√° un solo argumento, llamado `cifra`. Dentro del cuerpo de la funci√≥n, vemos que el objeto cifra, que viene desde el argumento, se multiplica por 1000. Como esta es la √∫nica y √∫ltima operaci√≥n dentro del cuerpo de la funci√≥n, su resultado ser√° lo que se retorne al ejecutarla.

Probemos nuestra primera funci√≥n y veamos su comportamiento:



```{r}
#| error: true
multiplicar_mil(4)

multiplicar_mil("hola")

multiplicar_mil(c(32, 65, 87))
```



Hagamos otro ejemplo:



```{r}
personas <- c("Basti", "Paula", "Catherine", "Luis", "Mar√≠a Jos√©")

saludar <- function(persona) {
  paste("¬°Hola ", persona, "!", sep = "")
}

saludar(personas)

saludar("Caro")
```



En esta funci√≥n, el argumento `persona` expuesto dentro de una funci√≥n `paste()` que genera un texto a partir de argumento. Como en el primer ejemplo se le entrega un vector a la funci√≥n, `paste()` produce m√∫ltiples textos con cada elemento del vector. O sea que nuestra funci√≥n funciona tanto para m√∫ltiples elementos como para uno solo.

Pasemos a una versi√≥n m√°s compleja de la funci√≥n anterior:



```{r}
saludar <- function(persona) {
  
  # pasar el nombre a may√∫sculas
  nombre_mayuscula <- toupper(persona)
  
  # crear un saludo uniendo el texto con el argumento
  saludo <- paste("¬°Hola ", nombre_mayuscula, "!", sep = "")
  
  # crear n√∫meros al azar
  n√∫meros <- sample(1:99, length(persona)) # uno por persona
  
  # agregar n√∫meros de la suerte
  saludo2 <- paste(saludo, "Tu n√∫mero de la suerte es", n√∫meros)
  
  saludo2
}

saludar(personas)
```


En este caso, dentro del cuerpo de la funci√≥n estamos realizando varias operaciones. Dentro de una funci√≥n podemos crear nuevos objetos, y usar esos nuevos objetos para realizar otras operaciones sobre ellos. De este modo podemos llevar a cabo acciones m√°s complejas. En el ejemplo, el argumento de la funci√≥n es transformado a may√∫sculas con `toupper()`, luego se inserta dentro del texto con `paste()`. Despu√©s, se crea un vector de n√∫meros al azar que contenga una cantidad de n√∫meros igual a la cantidad de elementos del vector que viene del argumento de la funci√≥n, para que haya un n√∫mero por persona. Finalmente, se usa nuevamente `paste()` junto a `sample()` para agregar el n√∫mero aleatorio, y se entrega el objeto final, que ser√° lo que la funci√≥n retorna.


Las funciones pueden tener m√°s de un argumento. Creemos una funci√≥n que use dos argumentos para calcular una estimaci√≥n de tiempo de viaje a partir de una velocidad y una distancia dados:



```{r}
calcular_tiempo <- function(velocidad, distancia) {
  
  # el tiempo de viaje equivale a la distancia dividida por la velocidad
  tiempo <- distancia/(velocidad/60) # pasar km/h a km/minutos
  
  paste("Tiempo de viaje:", round(tiempo, 1), "minutos")
}

calcular_tiempo(velocidad = 20, distancia = 5)
```



En este ejemplo, una funci√≥n que calcula el tiempo de viaje requiere dos argumentos: la velocidad y la distancia. Dentro de `function()` simplemente se definen los nombres de los argumentos, y se usan dentro del cuerpo de la funci√≥n para calcular lo necesario.

Al momento de ejecutar una funci√≥n, si ponemos los argumentos en el orden en que se especifican en la funci√≥n, no es necesario que pongamos el nombre del argumento antes de el valor:



```{r}
calcular_tiempo(velocidad = 22, distancia = 6)
calcular_tiempo(22, 6)
```



Tambi√©n podemos especificar valores por defecto para los argumentos al momento de crear la funci√≥n. √âstos valores por defecto ser√°n aplicados si es que el/la usuario/a no define los argumentos.



```{r}
#| error: true
# ejecutar funci√≥n sin argumentos
calcular_tiempo()
```



Como no definimos los argumentos, la funci√≥n retorna un error. Modifiquemos la funci√≥n para que tenga argumentos por defecto:



```{r}
# actualizar funci√≥n con valores por defecto
calcular_tiempo <- function(velocidad = 0, distancia = 1) {
  tiempo <- distancia/(velocidad/60)
  paste("Tiempo de viaje:", round(tiempo, 1), "minutos")
}

# volver a ejecutar sin argumentos, por lo que usar√° los argumentos por defecto
calcular_tiempo()
```



Ahora la funci√≥n no tira un error si no se definen los argumentos, aunque el resultado que entrega en estos casos no sea muy √∫til üòÖ


_¬øC√≥mo puede ayudarte la creaci√≥n de funciones para el an√°lisis de datos?_

- Si realizas una misma tarea frecuentemente, puedes guardarla a una funci√≥n para as√≠ **reutilizar** la operaci√≥n en varios momentos de tu c√≥digo.
- Si realizas una operaci√≥n matem√°tica o estad√≠stica sobre una columna, puedes guardarla como una funci√≥n para **simplificar** la lectura del c√≥digo
- Puedes simplificar los pasos de tu procesamiento de datos guard√°ndolos como funciones, cuya entrada son los datos y la salida son los datos procesados. De este modo puedes ocultar la complejidad, lo que produce scripts **m√°s legibles**.
- Puedes definir todas tus funciones en otro script, permiti√©ndote as√≠ tener scripts **m√°s ordenados** y **menos extensos**.

----

## Control de flujo
Las estructuras de control de flujo son el conjunto de reglas que hacen que, dentro de un proceso de an√°lisis de datos, se realicen (o no) ciertas acciones si es que condiciones espec√≠ficas se cumplen, o bien, que no ocurran ciertas cosas si es que las condiciones no lo permiten. En otras palabras, es una forma de hacer que tu proceso de an√°lisis de datos adquiera fluidez, al definir momentos en los que **el flujo del procesamiento es determinado por las condiciones que tu definas**. 

_¬øEn qu√© situaciones podr√≠a ser √∫til el control de flujo del c√≥digo?_
- Si un dato no cumple con un criterio espec√≠fico, corregirlo o descartarlo.
- Si los datos llegan en cierto estado, o con ciertas particularidades, realizar un paso extra de limpieza. 
- Si dentro de los datos existen observaciones de ciertas caracter√≠sticas, visualizar los datos de una manera espec√≠fica. 
- Si a la tabla de datos le falta una comuna columna, crearla. 
- Si una columna viene en un tipo que no es el esperado, convertirla al apropiado. 
- Si ocurre un error o el resultado no es aceptable, realizar la operaci√≥n de nuevo de una forma alternativa.

En la pr√°ctica, esta t√©cnica permite **crear condicionalidad en la ejecuci√≥n del c√≥digo** usando una comparaci√≥n, cuyo resultado (`TRUE`/`FALSE`) **decide si el c√≥digo siguiente se ejecutar√° o no**. El c√≥digo dentro de la condici√≥n s√≥lo se ejecuta si la comparaci√≥n retorna `TRUE`.

Creemos un ejemplo donde definimos un vector de n√∫meros, y si alguno de estos n√∫meros cumple con un criterio espec√≠fico, realizaremos una operaci√≥n que corrija la situaci√≥n:



```{r}
edades <- c(15, 17, 18, 24, 29, 31, 34, 36, 45, 49, 52)

edades

# si viene alguna edad que sea menor a 18 a√±os, ejecutar lo siguiente
if (any(edades < 18)) {
  # filtrar vector
  menores <- edades[edades < 18]
  
  message(paste("Se detectaron registros menores de 18 a√±os: eliminando",
                length(menores), "registros"))
  
  # dejar solamente las edades que son igual o mayor a 18
  edades <- edades[edades >= 18]
} 

edades
```



En este ejemplo, creamos un flujo de control donde un conjunto de datos se filtra s√≥lo
si se cumple un cierto criterio. Se usa la funci√≥n `any()` para detectar si es que existe alg√∫n elemento dentro del vector que cumpla con el criterio de ser menor de 18 a√±os. Si esto es as√≠, se ejecuta el c√≥digo dentro del `if`, que detecta las observaciones problem√°ticas, emite un mensaje, y finalmente filtra el vector para dejar solamente las observaciones v√°lidas, y lo retorna sobreescribiendo el vector original.

Probemos nuevamente cambiando el dato, agregando un mensaje que tambi√©n confirma
si la condici√≥n no se cumple:



```{r}
edades <- c(31, 34, 36, 45, 49, 52, 62, 63)

edades

# si viene alguna edad que sea menor a 18 a√±os, ejecutar lo siguiente
if (any(edades < 18)) {
  
  menores <- edades[edades < 18]
  
  message(paste("Se detectaron registros menores de 18 a√±os: eliminando", length(menores), "registros"))
  
  edades <- edades[edades >= 18]
} else {
  # emitir un mensaje si la condici√≥n no se cumple
  message("OK: todos los registros corresponden a mayores de 18 a√±os")
}
```



En el apartado `else` podemos especificar el c√≥digo que se ejecutar√° si la
condici√≥n que especificamos en el `if` retorna `FALSE`, o bien, simplemente podemos omitir el apartado `else` para que en cuyo caso no ocurra nada, como en el ejemplo anterior.

El control de flujo resulta particularmente √∫til para crear funciones m√°s complejas. Dentro de las funciones puedes crear condicionales que realizan operaciones espec√≠ficas dependiendo de lo que se le entregue a la funci√≥n. 



```{r}

```




Tambi√©n podemos crear nuevos argumentos en la funci√≥n que se usen en condicionales para alterar la operaci√≥n de la funci√≥n. As√≠ puedes hacer que tu funci√≥n trabaje de forma distinta dependiendo de lo que le especifiques.



```{r}

```




## Bucles 
Los bucles o loops son operaciones extremadamente √∫tiles. Permiten generalizar tu c√≥digo, en el sentido que una operaci√≥n u operaciones que definas pueden aplicarse repetidas veces sobre distintos objetos, con un alto grado de libertad en el proceso. 

En un bucle, se realiza una operaci√≥n m√∫ltiples veces en base a un vector que entregues. Por cada elemento del vector que entregues al bucle, el c√≥digo se ejecutar√°. En este sentido, el bucle tendr√° tantos pasos como elementos tenga el vector. Cuando entregas un vector al bucle, tambi√©n indicas c√≥mo se va a llamar la variable que representa al paso; es decir, la variable que va a contener el valor del vector que se corresponde al paso que se est√° ejecutando.

Por ejemplo:



```{r}
numeros <- c(1, 2, 3, 4)

for (paso in numeros) {
  print(paso)
}
```


En este ejemplo, creamos un vector `numeros` que contiene n√∫meros del 1 al 4. Luego, definimos un bucle con el operador `for`, que en espa√±ol se leer√≠a _‚Äúpor cada‚Äù_. El primer argumento que definimos luego del `for` es el nombre que tendr√° cada paso, luego `in`, y luego el vector. Entonces, se leer√≠a _‚Äúpor cada `paso` en `numeros`, ejecutar‚Ä¶‚Äù_. En el ejemplo, lo que se ejecutar√° es solamente retornar el valor de cada paso. Es decir, en el primer paso se retorna el valor 1 de `numeros`, en el segundo paso el valor 2, y as√≠ sucesivamente.

Otro ejemplo m√°s concreto:



```{r}
pasos <- 10:20

for (i in pasos) {
  texto <- paste("este es el paso:", i)
  print(texto)
}
```


En este caso, tenemos un vector de 10 n√∫meros, por lo que el c√≥digo especificado
se aplica a cada uno de los n√∫meros, usando el objeto `i` como si fuera el objeto 
que contiene el valor de cada paso (10, 11, 12, etc.).

Dentro de una iteraci√≥n tambi√©n podemos controlar el flujo del c√≥digo con `if else`:



```{r}
for (persona in personas) {
  
  saludo <- paste("Hola", persona)
  
  if (persona == "Mar√≠a Jos√©") {
    saludo <- paste0("¬°Hola amiguita ", persona, "!")
  }
  
  print(saludo)
}
```


En este caso, ponemos una excepci√≥n con un `if` para que, en un paso espec√≠fico del loop, el comportamiento sea distinto.

En este ejemplo, controlamos el flujo del c√≥digo para que hayan m√∫ltiples condiciones,
y para que en cada condici√≥n se haga algo distinto. Podemos evaluar m√∫ltiples condiciones con `else if`, que es una forma de hacer que si la comparaci√≥n anterior no coincidi√≥ con el valor, se intente se nuevo con la siguiente. Se pueden encadenar varios `else if`, y de este modo, se puede hacer que un solo valor vaya siendo evaluado en m√∫ltiples condiciones, a ver si coincide con alguna. Si coincide con alguna, se ejecuta el c√≥digo correspondiente a ese paso, y se sale del flujo. Pero si no coincide con ninguna, no pasar√° nada a menos que al final pongas un `else` que capture todos los dem√°s casos.



```{r}
for (persona in personas) {
  
  if (persona == "Basti") {
    saludo <- paste("¬°Hola a todes!")
    
  } else if (persona == "Catherine") {  
    saludo <- paste("Excelente pregunta, Catherine")
    
  } else if (persona == "Luis") {
    saludo <- sample(c("Serpiente", "Perro", "Gato", "Rata", "Gallina", "Pez"), 1)
    
  } else {
    saludo <- paste("Hola", persona)
  }
  
  print(saludo)
}
```


Por cada paso, el objeto `persona` asume el valor del elemento correspondiente del vector `personas`. El c√≥digo avanza dentro del loop probando si `persona` coincide con alguna de las condiciones dadas, y si no coincide, prueba si coincide la siguiente con `else if`, y al final, si el valor no coincidi√≥ con ninguna de las comparaciones espec√≠ficas de los `if`, entonces se realiza una operaci√≥n general para todos los dem√°s casos en `else`.

_¬øEn qu√© casos ser√≠a √∫til usar bucles o loops?_
- Si tienes m√∫ltiples objetos, observaciones, o tablas de datos, a las cuales quiera realizarles una misma operaci√≥n a todas al mismo tiempo.
- Si realizaste un an√°lisis, pero tienes que volver a realizar este mismo an√°lisis sobre muchas versiones distintas de un conjunto de datos (por ejemplo, cuando los datos vienen separados en distintos archivos por mes o por a√±o).
- Si tienes la ubicaci√≥n de muchos archivos, y quieres cargarlos todos al mismo tiempo.
- Si tienes un conjunto de datos que puedes filtrar por una variable, y quieres generar m√∫ltiples visualizaciones a partir de el filtrado de cada una de las categor√≠as de dicha variable. Por ejemplo, si tienes un conjunto de datos de 10 pa√≠ses, puedes enterar por los nombres de los pa√≠ses para generar 10 gr√°ficos, uno para cada pa√≠s.
- Si tienes un conjunto de datos con muchas variables, y a todas las variables quieres calcularle estad√≠sticos descriptivos, defines el c√°lculo de los estad√≠sticos descriptivos una vez, y lo pones dentro de una iteraci√≥n que vaya por todas las columnas del dataframe.


----

C√≥mo puedes ver, la creaci√≥n de funciones, el control de flujo, y los bucles o iteraciones son herramientas complementarias. Muchas veces, lo que podemos hacer con una funci√≥n queda mejor dentro de un bucle, o un bucle que dise√±amos puede ser insertado en una funci√≥n para nuestra conveniencia, y dentro de funciones o de bucle siempre vamos a estar usando el control de flujo para poder adaptarnos a todos los casos posibles que encontremos en nuestros datos.




{{< cafecito >}}

